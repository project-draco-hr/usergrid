{
  final Edge writtenEdge=write.getData();
  final OrganizationScope scope=write.getOrganizationScope();
  final UUID now=UUIDGenerator.newTimeUUID();
  return Observable.create(new ObservableIterator<MarkedEdge>("getEdgeVersions"){
    @Override protected Iterator<MarkedEdge> getIterator(){
      return commitLog.getEdgeVersions(scope,new SimpleSearchByEdge(writtenEdge.getSourceNode(),writtenEdge.getType(),writtenEdge.getTargetNode(),now,null));
    }
  }
).takeWhile(new Func1<MarkedEdge,Boolean>(){
    @Override public Boolean call(    final MarkedEdge markedEdge){
      return UUIDComparator.staticCompare(writtenEdge.getVersion(),markedEdge.getVersion()) < 0;
    }
  }
).buffer(graphFig.getScanPageSize()).map(new Func1<List<MarkedEdge>,EdgeEvent<Edge>>(){
    @Override public EdgeEvent<Edge> call(    final List<MarkedEdge> markedEdges){
      final MutationBatch storageWriteBatch=keyspace.prepareMutationBatch();
      final MutationBatch commitlogCleanBatch=keyspace.prepareMutationBatch();
      for (      MarkedEdge edge : markedEdges) {
        storageWriteBatch.mergeShallow(permanentStorage.writeEdge(scope,edge));
        commitlogCleanBatch.mergeShallow(commitLog.deleteEdge(scope,edge));
      }
      try {
        storageWriteBatch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("unable to execute mutation",e);
      }
      try {
        commitlogCleanBatch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("unable to execute mutation",e);
      }
      return write;
    }
  }
);
}
