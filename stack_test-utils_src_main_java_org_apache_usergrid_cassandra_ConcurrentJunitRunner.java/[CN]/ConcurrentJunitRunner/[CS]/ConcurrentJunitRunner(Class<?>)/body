{
  super(klass);
  setScheduler(new RunnerScheduler(){
    ExecutorService executorService=Executors.newFixedThreadPool(klass.isAnnotationPresent(Concurrent.class) ? klass.getAnnotation(Concurrent.class).threads() : (int)(Runtime.getRuntime().availableProcessors() * 1.5),new NamedThreadFactory(klass.getSimpleName()));
    CompletionService<Void> completionService=new ExecutorCompletionService<Void>(executorService);
    Queue<Future<Void>> tasks=new LinkedList<Future<Void>>();
    @Override public void schedule(    Runnable childStatement){
      tasks.offer(completionService.submit(childStatement,null));
    }
    @Override public void finished(){
      try {
        while (!tasks.isEmpty()) {
          tasks.remove(completionService.take());
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        while (!tasks.isEmpty()) {
          tasks.poll().cancel(true);
        }
        executorService.shutdownNow();
      }
    }
  }
);
}
