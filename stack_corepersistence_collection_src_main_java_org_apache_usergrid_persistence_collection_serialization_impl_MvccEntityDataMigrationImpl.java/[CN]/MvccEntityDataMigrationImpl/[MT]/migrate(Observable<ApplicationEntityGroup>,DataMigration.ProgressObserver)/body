{
  final AtomicLong atomicLong=new AtomicLong();
  final MutationBatch totalBatch=keyspace.prepareMutationBatch();
  final UUID now=UUIDGenerator.newTimeUUID();
  return applicationEntityGroupObservable.flatMap(new Func1<ApplicationEntityGroup,Observable<Id>>(){
    @Override public Observable call(    final ApplicationEntityGroup applicationEntityGroup){
      final List<EntityIdScope<CollectionScope>> entityIds=applicationEntityGroup.entityIds;
      return Observable.from(entityIds).subscribeOn(Schedulers.io()).map(new Func1<EntityIdScope<CollectionScope>,Id>(){
        @Override public Id call(        EntityIdScope<CollectionScope> idScope){
          MigrationStrategy.MigrationRelationship<MvccEntitySerializationStrategy> migration=entityMigrationStrategy.getMigration();
          if (idScope.getCollectionScope() instanceof CollectionScope) {
            CollectionScope currentScope=idScope.getCollectionScope();
            EntitySet allVersions=migration.from().load(currentScope,Collections.singleton(idScope.getId()),now);
            final MvccEntity version=allVersions.getEntity(idScope.getId());
            final MutationBatch versionBatch=migration.to().write(currentScope,version);
            totalBatch.mergeShallow(versionBatch);
            throw new UnsupportedOperationException("TODO, make this more functional in flushing");
          }
          return idScope.getId();
        }
      }
).buffer(100).doOnNext(new Action1<List<Id>>(){
        @Override public void call(        List<Id> ids){
          executeBatch(totalBatch,observer,atomicLong);
        }
      }
);
    }
  }
);
}
