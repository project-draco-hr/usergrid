{
  if (query == null) {
    query=new QueueQuery();
  }
  Keyspace ko=cass.getApplicationKeyspace(applicationId);
  queuePath=Queue.normalizeQueuePath(queuePath);
  if (queuePath == null) {
    queuePath="/";
  }
  logger.info("QueueManagerFactoryImpl.getFromQueue: {}",queuePath);
  UUID queueId=Queue.getQueueId(queuePath);
  UUID consumerId=query.getConsumerId();
  if ((consumerId == null) && (query.getPosition() == CONSUMER)) {
    consumerId=UUIDUtils.newTimeUUID();
  }
  boolean skip_first=false;
  UUID start_uuid=query.getLastMessageId();
  int prev_count=query.getPreviousCount();
  int next_count=query.getNextCount();
  int limit=query.getLimit();
  if (query.getPosition() == LAST) {
    if ((query.getLastTimestamp() == 0) && (start_uuid == null)) {
      start_uuid=getConsumerQueuePosition(ko,queueId,queueId);
      skip_first=(start_uuid != null);
    }
  }
 else   if (query.getPosition() == CONSUMER) {
    if ((query.getLastTimestamp() == 0) && (start_uuid == null)) {
      start_uuid=getConsumerQueuePosition(ko,consumerId,queueId);
      skip_first=(start_uuid != null);
    }
  }
 else   if (query.getPosition() == QueuePosition.START) {
    start_uuid=null;
    next_count=max(next_count,limit);
  }
 else   if (query.getPosition() == QueuePosition.END) {
    start_uuid=null;
    prev_count=max(prev_count,limit);
  }
  QueueBounds bounds=getQueueBounds(ko,queueId);
  TreeSet<UUID> uuid_set=new TreeSet<UUID>(new UUIDComparator());
  if (!query.hasFilterPredicates()) {
    if (prev_count > 0) {
      uuid_set=getQueueRange(ko,queueId,bounds,uuid_set,start_uuid,null,true,prev_count);
    }
    uuid_set=getQueueRange(ko,queueId,bounds,uuid_set,start_uuid,null,false,skip_first ? next_count + 1 : next_count);
  }
 else {
    QueryProcessor qp=new QueryProcessor(query);
    List<QuerySlice> slices=qp.getSlices();
    TreeSet<UUID> prev_set=null;
    if (prev_count > 0) {
      if (slices.size() > 1) {
        prev_count=DEFAULT_SEARCH_COUNT;
      }
      for (      QuerySlice slice : slices) {
        TreeSet<UUID> r=null;
        try {
          r=searchQueueRange(ko,queueId,bounds,null,start_uuid,null,true,slice,prev_count);
        }
 catch (        Exception e) {
          logger.error("Error during search",e);
        }
        if (prev_set != null) {
          mergeAnd(prev_set,r,true,10000);
        }
 else {
          prev_set=r;
        }
      }
    }
    TreeSet<UUID> next_set=null;
    if (slices.size() > 1) {
      next_count=DEFAULT_SEARCH_COUNT;
    }
    for (    QuerySlice slice : slices) {
      TreeSet<UUID> r=null;
      try {
        r=searchQueueRange(ko,queueId,bounds,null,start_uuid,null,false,slice,skip_first ? next_count + 1 : next_count);
      }
 catch (      Exception e) {
        logger.error("Error during search",e);
      }
      if (next_set != null) {
        mergeAnd(next_set,r,true,10000);
      }
 else {
        next_set=r;
      }
    }
  }
  if (skip_first) {
    uuid_set.remove(start_uuid);
  }
  List<UUID> uuid_list=new ArrayList<UUID>(uuid_set);
  UUIDUtils.sortReversed(uuid_list);
  limit=query.getLimit();
  if ((limit > 0) && (limit < uuid_list.size())) {
    uuid_list=uuid_list.subList(0,limit);
  }
  Rows<UUID,String,ByteBuffer> messageResults=createMultigetSliceQuery(ko,ue,se,be).setColumnFamily(MESSAGE_PROPERTIES.getColumnFamily()).setKeys(uuid_list).setRange(null,null,false,ALL_COUNT).execute().get();
  List<Message> messages=new ArrayList<Message>();
  for (  Row<UUID,String,ByteBuffer> row : messageResults) {
    Message message=deserializeMessage(row.getColumnSlice().getColumns());
    if (message != null) {
      messages.add(message);
    }
  }
  Message.sortReversed(messages);
  UUID lastUUID=null;
  if (messages.size() > 0) {
    lastUUID=messages.get(0).getUuid();
  }
 else   if (start_uuid != null) {
    lastUUID=start_uuid;
  }
  if (lastUUID != null) {
    Mutator<UUID> batch=createMutator(ko,ue);
    if (query.getPosition() == QueuePosition.LAST) {
      batch.addInsertion(queueId,CONSUMERS.getColumnFamily(),createColumn(queueId,lastUUID,cass.createTimestamp(),ue,ue));
    }
 else     if (query.getPosition() == QueuePosition.CONSUMER) {
      batch.addInsertion(consumerId,CONSUMERS.getColumnFamily(),createColumn(queueId,lastUUID,cass.createTimestamp(),ue,ue));
    }
    batchExecute(batch,RETRY_COUNT);
  }
  return new QueueResults(queuePath,queueId,messages,lastUUID,consumerId);
}
