{
  if ((bounds == null) && ((start_uuid == null) || (finish_uuid == null))) {
    logger.error("Necessary queue bounds not found");
    return uuid_set;
  }
  if (start_uuid == null) {
    if (reversed) {
      start_uuid=bounds.getNewest();
    }
 else {
      start_uuid=bounds.getOldest();
    }
  }
  if (start_uuid == null) {
    logger.error("No first message in queue");
    return uuid_set;
  }
  if (finish_uuid == null) {
    if (reversed) {
      finish_uuid=bounds.getOldest();
    }
 else {
      finish_uuid=bounds.getNewest();
    }
  }
  if (finish_uuid == null) {
    logger.error("No last message in queue");
    return uuid_set;
  }
  long start_ts_shard=roundLong(getTimestampInMillis(start_uuid),QUEUE_SHARD_INTERVAL);
  long finish_ts_shard=roundLong(getTimestampInMillis(finish_uuid),QUEUE_SHARD_INTERVAL);
  long current_ts_shard=start_ts_shard;
  if (reversed) {
    current_ts_shard=finish_ts_shard;
  }
  while ((current_ts_shard >= start_ts_shard) && (current_ts_shard <= finish_ts_shard)) {
    UUID slice_start=MIN_TIME_UUID;
    UUID slice_end=MAX_TIME_UUID;
    if (current_ts_shard == start_ts_shard) {
      slice_start=start_uuid;
    }
    if (current_ts_shard == finish_ts_shard) {
      slice_end=finish_uuid;
    }
    try {
      SliceQuery<ByteBuffer,UUID,ByteBuffer> q=createSliceQuery(ko,be,ue,be);
      q.setColumnFamily(QUEUE_INBOX.getColumnFamily());
      q.setKey(getQueueShardRowKey(queueId,current_ts_shard));
      q.setRange(slice_start,slice_end,reversed,limit);
      List<HColumn<UUID,ByteBuffer>> results=q.execute().get().getColumns();
      for (      HColumn<UUID,ByteBuffer> column : results) {
        uuid_set.add(column.getName());
        if (uuid_set.size() >= limit) {
          return uuid_set;
        }
      }
    }
 catch (    Exception e) {
      logger.error("Error getting previous messages",e);
      return uuid_set;
    }
    if (reversed) {
      current_ts_shard-=QUEUE_SHARD_INTERVAL;
    }
 else {
      current_ts_shard+=QUEUE_SHARD_INTERVAL;
    }
  }
  return uuid_set;
}
