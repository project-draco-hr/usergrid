{
  final UUID maxVersion=edge.getVersion();
  Observable<MarkedEdge> sourceEdges=getEdgeVersionsFromSource(scope,edge);
  Observable<MarkedEdge> targetEdges=getEdgeVersionsToTarget(scope,edge);
  return Observable.merge(sourceEdges,targetEdges).filter(new Func1<MarkedEdge,Boolean>(){
    /** 
 * We only want to return edges < this version so we remove them
 * @param markedEdge
 * @return
 */
    @Override public Boolean call(    final MarkedEdge markedEdge){
      return UUIDComparator.staticCompare(markedEdge.getVersion(),maxVersion) < 0;
    }
  }
).distinctUntilChanged().buffer(graphFig.getScanPageSize()).flatMap(new Func1<List<MarkedEdge>,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final List<MarkedEdge> markedEdges){
      final MutationBatch batch=keyspace.prepareMutationBatch();
      for (      MarkedEdge edge : markedEdges) {
        final MutationBatch delete=edgeSerialization.deleteEdge(scope,edge);
        batch.mergeShallow(delete);
      }
      try {
        batch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to issue write to cassandra",e);
      }
      return Observable.from(markedEdges).subscribeOn(scheduler);
    }
  }
);
}
