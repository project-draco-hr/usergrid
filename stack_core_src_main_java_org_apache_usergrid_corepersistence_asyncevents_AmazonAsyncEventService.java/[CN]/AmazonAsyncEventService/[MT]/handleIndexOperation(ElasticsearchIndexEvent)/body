{
  Preconditions.checkNotNull(elasticsearchIndexEvent,"elasticsearchIndexEvent cannot be null");
  final UUID messageId=elasticsearchIndexEvent.getIndexBatchId();
  Preconditions.checkNotNull(messageId,"messageId must not be null");
  final String message=esMapPersistence.getString(messageId.toString());
  final IndexOperationMessage indexOperationMessage;
  if (message == null) {
    logger.warn("Received message with id {} to process, unable to find it, reading with higher consistency level",messageId);
    final String highConsistency=esMapPersistence.getStringHighConsistency(messageId.toString());
    if (highConsistency == null) {
      logger.error("Unable to find the ES batch with id {} to process at a higher consistency level",messageId);
      throw new RuntimeException("Unable to find the ES batch to process with message id " + messageId);
    }
    indexOperationMessage=ObjectJsonSerializer.INSTANCE.fromString(highConsistency,IndexOperationMessage.class);
  }
 else {
    indexOperationMessage=ObjectJsonSerializer.INSTANCE.fromString(message,IndexOperationMessage.class);
  }
  Preconditions.checkNotNull(indexOperationMessage,"indexOperationMessage cannot be null");
  Preconditions.checkArgument(!indexOperationMessage.isEmpty(),"queued indexOperationMessage messages should not be empty");
  indexProducer.put(indexOperationMessage).toBlocking().last();
}
