{
synchronized (mutex) {
    final AtomicInteger countFail=new AtomicInteger();
    Observable<List<IndexOperationMessage>> consumer=Observable.create(new Observable.OnSubscribe<List<IndexOperationMessage>>(){
      @Override public void call(      final Subscriber<? super List<IndexOperationMessage>> subscriber){
        Thread.currentThread().setName("QueueConsumer_" + Thread.currentThread().getId());
        List<IndexOperationMessage> drainList;
        do {
          try {
            Timer.Context timer=produceTimer.time();
            drainList=bufferQueue.take(config.getIndexBufferSize(),config.getIndexBufferTimeout(),TimeUnit.MILLISECONDS);
            subscriber.onNext(drainList);
            timer.stop();
            countFail.set(0);
          }
 catch (          EsRejectedExecutionException err) {
            countFail.incrementAndGet();
            log.error("Elasticsearch rejected our request, sleeping for {} milliseconds before retrying.  " + "Failed {} consecutive times",config.getFailRefreshCount(),countFail.get());
            try {
              Thread.sleep(config.getFailureRetryTime());
            }
 catch (            InterruptedException e) {
            }
          }
catch (          Exception e) {
            int count=countFail.incrementAndGet();
            log.error("failed to dequeue",e);
            if (count > 200) {
              log.error("Shutting down index drain due to repetitive failures");
            }
          }
        }
 while (true);
      }
    }
).subscribeOn(Schedulers.newThread()).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      List<IndexOperationMessage> containerList){
        if (containerList.size() > 0) {
          flushMeter.mark(containerList.size());
          Timer.Context time=flushTimer.time();
          execute(containerList);
          time.stop();
        }
      }
    }
).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      final List<IndexOperationMessage> indexOperationMessages){
        bufferQueue.ack(indexOperationMessages);
      }
    }
);
    subscription=consumer.subscribe();
  }
}
