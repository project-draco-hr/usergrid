{
synchronized (mutex) {
    Observable<List<IndexOperationMessage>> consumer=Observable.create(new Observable.OnSubscribe<List<IndexOperationMessage>>(){
      @Override public void call(      final Subscriber<? super List<IndexOperationMessage>> subscriber){
        Thread.currentThread().setName("QueueConsumer_" + counter.incrementAndGet());
        List<IndexOperationMessage> drainList=null;
        do {
          Timer.Context timer=produceTimer.time();
          try {
            drainList=bufferQueue.take(config.getIndexBufferSize(),config.getIndexBufferTimeout(),TimeUnit.MILLISECONDS);
            subscriber.onNext(drainList);
            inFlight.addAndGet(drainList.size());
            timer.stop();
          }
 catch (          Throwable t) {
            final long sleepTime=config.getFailureRetryTime();
            log.error("Failed to dequeue.  Sleeping for {} milliseconds",sleepTime,t);
            if (drainList != null) {
              inFlight.addAndGet(-1 * drainList.size());
            }
            try {
              Thread.sleep(sleepTime);
            }
 catch (            InterruptedException ie) {
            }
            indexErrorCounter.inc();
          }
        }
 while (true);
      }
    }
).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      List<IndexOperationMessage> containerList){
        if (containerList.size() == 0) {
          return;
        }
        flushMeter.mark(containerList.size());
        Timer.Context time=flushTimer.time();
        execute(containerList);
        time.stop();
      }
    }
).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      final List<IndexOperationMessage> indexOperationMessages){
        bufferQueue.ack(indexOperationMessages);
        inFlight.addAndGet(-1 * indexOperationMessages.size());
      }
    }
).subscribeOn(Schedulers.newThread());
    final Subscription subscription=consumer.subscribe();
    subscriptions.add(subscription);
  }
}
