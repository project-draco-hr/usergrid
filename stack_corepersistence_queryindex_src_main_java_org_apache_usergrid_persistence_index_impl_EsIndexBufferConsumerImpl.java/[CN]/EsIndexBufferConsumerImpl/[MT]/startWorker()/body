{
synchronized (mutex) {
    Observable<List<IndexOperationMessage>> consumer=Observable.create(new Observable.OnSubscribe<List<IndexOperationMessage>>(){
      @Override public void call(      final Subscriber<? super List<IndexOperationMessage>> subscriber){
        Thread.currentThread().setName("QueueConsumer_" + counter.incrementAndGet());
        List<IndexOperationMessage> drainList;
        do {
          try {
            Timer.Context timer=produceTimer.time();
            drainList=bufferQueue.take(config.getIndexBufferSize(),config.getIndexBufferTimeout(),TimeUnit.MILLISECONDS);
            subscriber.onNext(drainList);
            inFlight.addAndGet(drainList.size());
            timer.stop();
          }
 catch (          Exception e) {
            final long sleepTime=config.getFailureRetryTime();
            log.error("Failed to dequeue.  Sleeping for {} milliseconds",sleepTime,e);
            try {
              Thread.sleep(sleepTime);
            }
 catch (            InterruptedException ie) {
            }
            indexErrorCounter.inc();
          }
        }
 while (true);
      }
    }
).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      List<IndexOperationMessage> containerList){
        if (containerList.size() == 0) {
          return;
        }
        flushMeter.mark(containerList.size());
        Timer.Context time=flushTimer.time();
        execute(containerList);
        time.stop();
      }
    }
).doOnNext(new Action1<List<IndexOperationMessage>>(){
      @Override public void call(      final List<IndexOperationMessage> indexOperationMessages){
        bufferQueue.ack(indexOperationMessages);
        inFlight.addAndGet(-1 * indexOperationMessages.size());
      }
    }
).onErrorReturn(new Func1<Throwable,List<IndexOperationMessage>>(){
      @Override public List<IndexOperationMessage> call(      final Throwable throwable){
        final long sleepTime=config.getFailureRetryTime();
        log.error("Failed to dequeue.  Sleeping for {} milliseconds",sleepTime,throwable);
        try {
          Thread.sleep(sleepTime);
        }
 catch (        InterruptedException ie) {
        }
        indexErrorCounter.inc();
        return Collections.EMPTY_LIST;
      }
    }
).subscribeOn(Schedulers.newThread());
    final Subscription subscription=consumer.subscribe();
    subscriptions.add(subscription);
  }
}
