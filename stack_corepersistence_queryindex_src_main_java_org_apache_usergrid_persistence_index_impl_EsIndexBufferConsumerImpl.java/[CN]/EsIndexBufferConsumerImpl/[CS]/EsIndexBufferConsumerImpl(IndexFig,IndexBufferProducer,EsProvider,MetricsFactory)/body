{
  this.flushTimer=metricsFactory.getTimer(EsIndexBufferConsumerImpl.class,"index.buffer.flush");
  this.indexSizeCounter=metricsFactory.getCounter(EsIndexBufferConsumerImpl.class,"index.buffer.size");
  this.config=config;
  this.failureMonitor=new FailureMonitorImpl(config,provider);
  this.client=provider.getClient();
  final AtomicLong queueSize=new AtomicLong();
  this.consumer=Observable.create(producer).subscribeOn(Schedulers.io()).doOnNext(new Action1<IndexOperationMessage>(){
    @Override public void call(    IndexOperationMessage requestBuilderContainer){
      queueSize.addAndGet(requestBuilderContainer.getBuilder().size());
    }
  }
).buffer(config.getIndexBufferTimeout(),TimeUnit.MILLISECONDS,config.getIndexBufferSize()).doOnNext(new Action1<List<IndexOperationMessage>>(){
    @Override public void call(    List<IndexOperationMessage> containerList){
      flushTimer.time();
      if (containerList.size() > 0) {
        execute(containerList);
      }
    }
  }
);
  consumer.subscribe();
}
