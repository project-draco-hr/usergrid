{
  final TaskExecutor taskExecutor=new NamedTaskExecutorImpl("test",1,0);
  final SerializationFig serializationFig=mock(SerializationFig.class);
  when(serializationFig.getBufferSize()).thenReturn(10);
  final MvccEntitySerializationStrategy mvccEntitySerializationStrategy=mock(MvccEntitySerializationStrategy.class);
  final MvccLogEntrySerializationStrategy mvccLogEntrySerializationStrategy=mock(MvccLogEntrySerializationStrategy.class);
  final Keyspace keyspace1=mock(Keyspace.class);
  final Keyspace keyspace2=mock(Keyspace.class);
  final MutationBatch entityBatch=mock(MutationBatch.class);
  final MutationBatch logBatch=mock(MutationBatch.class);
  when(keyspace1.prepareMutationBatch()).thenReturn(mock(MutationBatch.class)).thenReturn(entityBatch).thenReturn(logBatch);
  when(keyspace2.prepareMutationBatch()).thenReturn(mock(MutationBatch.class)).thenReturn(entityBatch).thenReturn(logBatch);
  final int sizeToReturn=10;
  final int listenerCount=2;
  final CountDownLatch latch=new CountDownLatch(sizeToReturn / serializationFig.getBufferSize() * listenerCount);
  final Semaphore waitSemaphore=new Semaphore(0);
  final SlowListener slowListener=new SlowListener(latch,waitSemaphore);
  final EntityVersionDeletedTest runListener=new EntityVersionDeletedTest(latch);
  final Id applicationId=new SimpleId("application");
  final CollectionScope appScope=new CollectionScopeImpl(applicationId,applicationId,"users");
  final Id entityId=new SimpleId("user");
  final LogEntryMock logEntryMock=LogEntryMock.createLogEntryMock(mvccLogEntrySerializationStrategy,appScope,entityId,sizeToReturn + 1);
  final UUID version=logEntryMock.getEntries().iterator().next().getVersion();
  final UniqueValueSerializationStrategy uniqueValueSerializationStrategy=mock(UniqueValueSerializationStrategy.class);
  EntityVersionCleanupTask firstTask=new EntityVersionCleanupTask(serializationFig,mvccLogEntrySerializationStrategy,mvccEntitySerializationStrategy,uniqueValueSerializationStrategy,keyspace1,Sets.newSet((EntityVersionDeleted)runListener),appScope,entityId,version);
  EntityVersionCleanupTask secondTask=new EntityVersionCleanupTask(serializationFig,mvccLogEntrySerializationStrategy,mvccEntitySerializationStrategy,uniqueValueSerializationStrategy,keyspace2,Sets.newSet((EntityVersionDeleted)runListener),appScope,entityId,version);
  final MutationBatch batch=mock(MutationBatch.class);
  when(mvccEntitySerializationStrategy.delete(same(appScope),same(entityId),any(UUID.class))).thenReturn(batch);
  when(mvccLogEntrySerializationStrategy.delete(same(appScope),same(entityId),any(UUID.class))).thenReturn(batch);
  ListenableFuture<Void> future1=taskExecutor.submit(firstTask);
  ListenableFuture<Void> future2=taskExecutor.submit(secondTask);
  future2.get();
  while (!future1.isDone()) {
    Thread.sleep(200);
    waitSemaphore.release(listenerCount);
  }
  future1.get();
  verify(logBatch,times(sizeToReturn * 2)).mergeShallow(any(MutationBatch.class));
  verify(entityBatch,times(sizeToReturn * 2)).mergeShallow(any(MutationBatch.class));
  verify(logBatch,times(2)).execute();
  verify(entityBatch,times(2)).execute();
  latch.await();
}
