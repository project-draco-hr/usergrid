{
  final SerializationFig serializationFig=mock(SerializationFig.class);
  when(serializationFig.getBufferSize()).thenReturn(10);
  final int sizeToReturn=10;
  final int listenerCount=5;
  final CountDownLatch latch=new CountDownLatch(sizeToReturn / serializationFig.getBufferSize() * listenerCount);
  final Semaphore waitSemaphore=new Semaphore(0);
  final SlowListener listener1=new SlowListener(latch,waitSemaphore);
  final SlowListener listener2=new SlowListener(latch,waitSemaphore);
  final SlowListener listener3=new SlowListener(latch,waitSemaphore);
  final SlowListener listener4=new SlowListener(latch,waitSemaphore);
  final SlowListener listener5=new SlowListener(latch,waitSemaphore);
  final Set<EntityVersionDeleted> listeners=new HashSet<EntityVersionDeleted>();
  listeners.add(listener1);
  listeners.add(listener2);
  listeners.add(listener3);
  listeners.add(listener4);
  listeners.add(listener5);
  final MvccLogEntrySerializationStrategy less=mock(MvccLogEntrySerializationStrategy.class);
  final UniqueValueSerializationStrategy uvss=mock(UniqueValueSerializationStrategy.class);
  final Keyspace keyspace=mock(Keyspace.class);
  final MutationBatch entityBatch=mock(MutationBatch.class);
  when(keyspace.prepareMutationBatch()).thenReturn(mock(MutationBatch.class)).thenReturn(entityBatch);
  final Id applicationId=new SimpleId("application");
  final ApplicationScope appScope=new ApplicationScopeImpl(applicationId);
  final Id entityId=new SimpleId("user");
  final List<UUID> versions=VersionGenerator.generateVersions(2);
  final LogEntryMock logEntryMock=LogEntryMock.createLogEntryMock(less,appScope,entityId,versions);
  final UUID version=logEntryMock.getEntryAtIndex(0).getVersion();
  final UniqueValueEntryMock uniqueValueEntryMock=UniqueValueEntryMock.createUniqueMock(uvss,appScope,entityId,versions);
  EntityVersionCleanupTask cleanupTask=new EntityVersionCleanupTask(serializationFig,less,uvss,keyspace,listeners,appScope,entityId,version,false);
  final MutationBatch newBatch=mock(MutationBatch.class);
  when(uvss.delete(same(appScope),any(UniqueValue.class))).thenReturn(newBatch);
  when(less.delete(same(appScope),same(entityId),any(UUID.class))).thenReturn(newBatch);
  ListenableFuture<Void> future=taskExecutor.submit(cleanupTask);
  while (!future.isDone()) {
    Thread.sleep(200);
    waitSemaphore.release(listenerCount);
  }
  future.get();
  final UniqueValue oldUniqueField=uniqueValueEntryMock.getEntryAtIndex(1);
  final MvccLogEntry expectedDeletedEntry=logEntryMock.getEntryAtIndex(1);
  verify(uvss).delete(same(appScope),same(oldUniqueField));
  verify(less).delete(same(appScope),same(entityId),same(expectedDeletedEntry.getVersion()));
  verify(entityBatch).execute();
  latch.await();
  verify(uvss).delete(same(appScope),same(oldUniqueField));
  verify(less).delete(same(appScope),same(entityId),same(expectedDeletedEntry.getVersion()));
  verify(entityBatch).execute();
  latch.await();
  latch.await();
}
