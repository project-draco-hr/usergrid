{
  final SerializationFig serializationFig=mock(SerializationFig.class);
  when(serializationFig.getBufferSize()).thenReturn(10);
  final MvccEntitySerializationStrategy ess=mock(MvccEntitySerializationStrategy.class);
  final UniqueValueSerializationStrategy uniqueValueSerializationStrategy=mock(UniqueValueSerializationStrategy.class);
  final MvccLogEntrySerializationStrategy mvccLogEntrySerializationStrategy=mock(MvccLogEntrySerializationStrategy.class);
  final Keyspace keyspace=mock(Keyspace.class);
  final MutationBatch entityBatch=mock(MutationBatch.class);
  final MutationBatch logBatch=mock(MutationBatch.class);
  when(keyspace.prepareMutationBatch()).thenReturn(mock(MutationBatch.class)).thenReturn(entityBatch).thenReturn(logBatch);
  final int sizeToReturn=10;
  final CountDownLatch latch=new CountDownLatch(sizeToReturn / serializationFig.getBufferSize() * 3);
  final EntityVersionDeletedTest listener1=new EntityVersionDeletedTest(latch);
  final EntityVersionDeletedTest listener2=new EntityVersionDeletedTest(latch);
  final EntityVersionDeletedTest listener3=new EntityVersionDeletedTest(latch);
  final Set<EntityVersionDeleted> listeners=new HashSet<EntityVersionDeleted>();
  listeners.add(listener1);
  listeners.add(listener2);
  listeners.add(listener3);
  final Id applicationId=new SimpleId("application");
  final CollectionScope appScope=new CollectionScopeImpl(applicationId,applicationId,"users");
  final Id entityId=new SimpleId("user");
  final LogEntryMock logEntryMock=LogEntryMock.createLogEntryMock(mvccLogEntrySerializationStrategy,appScope,entityId,sizeToReturn + 1);
  final UUID version=logEntryMock.getEntries().iterator().next().getVersion();
  EntityVersionCleanupTask cleanupTask=new EntityVersionCleanupTask(serializationFig,mvccLogEntrySerializationStrategy,ess,uniqueValueSerializationStrategy,keyspace,listeners,appScope,entityId,version);
  final MutationBatch batch=mock(MutationBatch.class);
  when(ess.delete(same(appScope),same(entityId),any(UUID.class))).thenReturn(batch);
  when(mvccLogEntrySerializationStrategy.delete(same(appScope),same(entityId),any(UUID.class))).thenReturn(batch);
  final List<MvccEntity> mel=new ArrayList<MvccEntity>();
  Entity entity=new Entity(entityId);
  mel.add(new MvccEntityImpl(entityId,UUIDGenerator.newTimeUUID(),MvccEntity.Status.DELETED,Optional.of(entity)));
  mel.add(new MvccEntityImpl(entityId,UUIDGenerator.newTimeUUID(),MvccEntity.Status.DELETED,Optional.of(entity)));
  when(ess.load(same(appScope),same(entityId),any(UUID.class),any(Integer.class))).thenReturn(mel.iterator());
  ListenableFuture<Void> future=taskExecutor.submit(cleanupTask);
  future.get();
  verify(entityBatch,times(1)).mergeShallow(any(MutationBatch.class));
  verify(logBatch,times(1)).mergeShallow(any(MutationBatch.class));
  verify(logBatch).execute();
  verify(entityBatch).execute();
  latch.await();
}
