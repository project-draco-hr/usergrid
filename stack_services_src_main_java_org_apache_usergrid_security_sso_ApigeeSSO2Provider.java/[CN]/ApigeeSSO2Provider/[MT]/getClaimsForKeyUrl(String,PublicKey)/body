{
  Jws<Claims> claims=null;
  if (ssoPublicKey == null) {
    throw new IllegalArgumentException("Public key must be provided with Apigee JWT " + "token in order to verify signature.");
  }
  int tries=0;
  int maxTries=2;
  while (claims == null && tries++ < maxTries) {
    try {
      claims=Jwts.parser().setSigningKey(ssoPublicKey).parseClaimsJws(token);
    }
 catch (    SignatureException se) {
      logger.warn("Signature was invalid for Apigee JWT token: {} and key: {}",token,ssoPublicKey);
    }
catch (    ExpiredJwtException e) {
      final long expiry=Long.valueOf(e.getClaims().get("exp").toString());
      final long expirationDelta=((System.currentTimeMillis() / 1000) - expiry) * 1000;
      logger.info(String.format("Apigee JWT Token expired %d milliseconds ago.",expirationDelta));
    }
catch (    MalformedJwtException me) {
      logger.error("Malformed JWT token",me);
      throw new BadTokenException("Malformed Apigee JWT token",me);
    }
catch (    ArrayIndexOutOfBoundsException aio) {
      logger.error("Error parsing JWT token",aio);
      throw new BadTokenException("Error parsing Apigee JWT token",aio);
    }
    if (claims == null) {
      this.publicKey=getPublicKey(getExternalSSOUrl());
    }
  }
  return claims;
}
