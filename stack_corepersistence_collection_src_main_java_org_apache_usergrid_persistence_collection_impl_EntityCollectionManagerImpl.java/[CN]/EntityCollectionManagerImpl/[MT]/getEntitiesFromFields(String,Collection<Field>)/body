{
  return rx.Observable.just(fields).map(new Func1<Collection<Field>,FieldSet>(){
    @Override public FieldSet call(    Collection<Field> fields){
      try {
        final UUID startTime=UUIDGenerator.newTimeUUID();
        UniqueValueSet set=uniqueValueSerializationStrategy.load(applicationScope,type,fields);
        if (!set.iterator().hasNext()) {
          return new MutableFieldSet(0);
        }
        List<Id> entityIds=new ArrayList<>(fields.size());
        List<UniqueValue> uniqueValues=new ArrayList<>(fields.size());
        for (        final Field expectedField : fields) {
          UniqueValue value=set.getValue(expectedField.getName());
          if (value == null) {
            logger.debug("Field does not correspond to a unique value");
          }
          entityIds.add(value.getEntityId());
          uniqueValues.add(value);
        }
        final EntitySet entitySet=entitySerializationStrategy.load(applicationScope,entityIds,startTime);
        final MutationBatch deleteBatch=keyspace.prepareMutationBatch();
        final MutableFieldSet response=new MutableFieldSet(fields.size());
        for (        final UniqueValue expectedUnique : uniqueValues) {
          final MvccEntity entity=entitySet.getEntity(expectedUnique.getEntityId());
          if (entity == null || !entity.getEntity().isPresent()) {
            final MutationBatch valueDelete=uniqueValueSerializationStrategy.delete(applicationScope,expectedUnique);
            deleteBatch.mergeShallow(valueDelete);
            continue;
          }
          response.addEntity(expectedUnique.getField(),entity);
        }
        deleteBatch.execute();
        return response;
      }
 catch (      ConnectionException e) {
        logger.error("Failed to getIdField",e);
        throw new RuntimeException(e);
      }
    }
  }
);
}
