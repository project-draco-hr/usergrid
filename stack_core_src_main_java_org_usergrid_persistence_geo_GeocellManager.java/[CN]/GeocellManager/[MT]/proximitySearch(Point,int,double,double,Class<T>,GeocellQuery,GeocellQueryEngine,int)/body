{
  List<EntityLocationComparableTuple<T>> entityLocations=new ArrayList<EntityLocationComparableTuple<T>>(maxResults);
  Validate.isTrue(maxGeocellResolution < MAX_GEOCELL_RESOLUTION + 1,"Invalid max resolution parameter. Must be inferior to ",MAX_GEOCELL_RESOLUTION);
  String curContainingGeocell=GeocellUtils.compute(center,maxGeocellResolution);
  Set<String> searchedCells=new HashSet<String>();
  List<String> curGeocells=new ArrayList<String>();
  List<String> curGeocellsUnique=null;
  curGeocells.add(curContainingGeocell);
  double closestPossibleNextResultDist=0;
  int noDirection[]={0,0};
  List<Tuple<int[],Double>> sortedEdgesDistances=Arrays.asList(new Tuple<int[],Double>(noDirection,0d));
  boolean done=false;
  while (!curGeocells.isEmpty() && entityLocations.size() < maxResults) {
    closestPossibleNextResultDist=sortedEdgesDistances.get(0).getSecond();
    if (maxDistance > 0 && closestPossibleNextResultDist > maxDistance) {
      break;
    }
    Set<String> curTempUnique=new HashSet<String>(curGeocells);
    curTempUnique.removeAll(searchedCells);
    curGeocellsUnique=new ArrayList<String>(curTempUnique);
    List<T> queryResults=queryEngine.query(baseQuery,curGeocellsUnique,entityClass);
    searchedCells.addAll(curGeocells);
    for (    T entity : queryResults) {
      double distance=GeocellUtils.distance(center,GeocellUtils.getLocation(entity));
      if (distance < minDistance || (maxDistance != 0 && distance > maxDistance)) {
        continue;
      }
      EntityLocationComparableTuple<T> entityLocation=new EntityLocationComparableTuple<T>(entity,distance);
      int index=Collections.binarySearch(entityLocations,entityLocation);
      if (index > -1) {
        if (entityLocations.get(index).equals(entityLocation)) {
          continue;
        }
        index++;
      }
 else {
        index=(index + 1) * -1;
      }
      entityLocations.add(index,entityLocation);
      if (entityLocations.size() > maxResults) {
        entityLocations.remove(entityLocations.size() - 1);
      }
    }
    if (done) {
      break;
    }
    sortedEdgesDistances=GeocellUtils.distanceSortedEdges(curGeocells,center);
    if (queryResults.size() == 0 || curGeocells.size() == 4) {
      curContainingGeocell=curContainingGeocell.substring(0,Math.max(curContainingGeocell.length() - 1,0));
      if (curContainingGeocell.length() == 0) {
        curGeocells.clear();
        String[] items="0123456789abcdef".split("(?!^)");
        for (        String item : items)         curGeocells.add(item);
        done=true;
      }
 else {
        List<String> oldCurGeocells=new ArrayList<String>(curGeocells);
        curGeocells.clear();
        for (        String cell : oldCurGeocells) {
          if (cell.length() > 0) {
            String newCell=cell.substring(0,cell.length() - 1);
            if (!curGeocells.contains(newCell)) {
              curGeocells.add(newCell);
            }
          }
        }
      }
    }
 else     if (curGeocells.size() == 1) {
      for (int i=0; i < sortedEdgesDistances.size(); i++) {
        int nearestEdge[]=sortedEdgesDistances.get(i).getFirst();
        String edge=GeocellUtils.adjacent(curGeocells.get(0),nearestEdge);
        if (edge == null) {
          continue;
        }
        curGeocells.add(edge);
        break;
      }
    }
 else     if (curGeocells.size() == 2) {
      int nearestEdge[]=GeocellUtils.distanceSortedEdges(Arrays.asList(curContainingGeocell),center).get(0).getFirst();
      int[] perpendicularNearestEdge={0,0};
      if (nearestEdge[0] == 0) {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] != 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
 else {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] == 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
      List<String> tempCells=new ArrayList<String>();
      for (      String cell : curGeocells) {
        tempCells.add(GeocellUtils.adjacent(cell,perpendicularNearestEdge));
      }
      curGeocells.addAll(tempCells);
    }
    if (entityLocations.size() < maxResults) {
      continue;
    }
  }
  return new SearchResults<T>(entityLocations,curGeocells.get(0).length());
}
