{
  final AtomicLong counter=new AtomicLong();
  final MigrationRelationship<EdgeMetadataSerialization> migration=allVersions.getMigrationRelationship(currentVersion);
  final Observable<List<Edge>> observable=migrationDataProvider.getData().flatMap(new Func1<ApplicationScope,Observable<List<Edge>>>(){
    @Override public Observable<List<Edge>> call(    final ApplicationScope applicationScope){
      final GraphManager gm=graphManagerFactory.createEdgeManager(applicationScope);
      final Observable<Edge> edgesFromSource=edgesFromSourceObservable.edgesFromSource(gm,applicationScope.getApplication());
      logger.info("Migrating edges scope {}",applicationScope);
      return edgesFromSource.buffer(1000).parallel(new Func1<Observable<List<Edge>>,Observable<List<Edge>>>(){
        @Override public Observable<List<Edge>> call(        final Observable<List<Edge>> listObservable){
          return listObservable.doOnNext(new Action1<List<Edge>>(){
            @Override public void call(            List<Edge> edges){
              final MutationBatch batch=keyspace.prepareMutationBatch();
              for (              Edge edge : edges) {
                logger.info("Migrating meta for edge {}",edge);
                final MutationBatch edgeBatch=migration.to.writeEdge(applicationScope,edge);
                batch.mergeShallow(edgeBatch);
              }
              try {
                batch.execute();
              }
 catch (              ConnectionException e) {
                throw new RuntimeException("Unable to perform migration",e);
              }
              final long newCount=counter.addAndGet(edges.size());
              observer.update(migration.to.getImplementationVersion(),String.format("Currently running.  Rewritten %d edge types",newCount));
            }
          }
);
        }
      }
);
    }
  }
);
  observable.longCount().toBlocking().last();
  return migration.to.getImplementationVersion();
}
