{
  final AsynchronousErrorListener listener=new AsynchronousErrorListener();
  final TestEvent event=new TestEvent();
  final boolean[] invoked=new boolean[]{false,false};
  final AsynchronousEvent<TestEvent> asynchronousEvent=new AsynchronousEvent<TestEvent>(){
    @Override public TestEvent getEvent(){
      return event;
    }
    @Override public long getTimeout(){
      return 500;
    }
  }
;
  final TimeoutQueue queue=mock(TimeoutQueue.class);
  final AsyncProcessorImpl asyncProcessor=constructProcessor(queue,listener);
  final CountDownLatch latch=new CountDownLatch(1);
  final AsynchronousEvent<?>[] errorEvents={null};
  asyncProcessor.addErrorListener(new ErrorListener<TestEvent>(){
    @Override public void onError(    final AsynchronousEvent<TestEvent> event,    final Throwable t){
      errorEvents[0]=event;
      invoked[1]=true;
      latch.countDown();
    }
  }
);
  when(queue.remove(asynchronousEvent)).then(new Answer<Boolean>(){
    @Override public Boolean answer(    final InvocationOnMock invocation) throws Throwable {
      invoked[0]=true;
      return false;
    }
  }
);
  asyncProcessor.start(asynchronousEvent);
  latch.await();
  final TestEvent firedEvent=listener.events.peek();
  assertSame(event,firedEvent);
  assertFalse("Queue remove should not be invoked",invoked[0]);
  assertTrue("Error listener should be invoked",invoked[1]);
  assertEquals(event,errorEvents[0].getEvent());
}
