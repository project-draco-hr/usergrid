{
  final long uniqueEntrySize=10000000000l;
  final int numCountIncrement=10;
  final int entryIncrement=1000;
  final int concurrentWorkers=Runtime.getRuntime().availableProcessors() * 2;
  ExecutorService service=Executors.newFixedThreadPool(concurrentWorkers);
  final long countPerWorker=uniqueEntrySize / concurrentWorkers;
  final CountMinSketch counter=new CountMinSketch(EPS_OF_TOTAL_COUNT,CONFIDENCE,SEED);
  Stack<Future<Void>> futures=new Stack<Future<Void>>();
  final Object mutex=new Object();
  for (int i=0; i < concurrentWorkers; i++) {
    Future<Void> future=service.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        for (long i=0; i < countPerWorker; i++) {
          byte[] bytes=UUID_SER.toByteBuffer(UUIDGenerator.newTimeUUID()).array();
          long hash=MurmurHash.hash64(bytes);
          for (int j=0; j < numCountIncrement; j++) {
synchronized (mutex) {
              counter.add(hash,entryIncrement);
            }
          }
          assertCardinality(counter,hash,entryIncrement * numCountIncrement,uniqueEntrySize,EPS_OF_TOTAL_COUNT);
        }
        return null;
      }
    }
);
    futures.push(future);
  }
  for (  Future<Void> future : futures) {
    future.get();
  }
}
