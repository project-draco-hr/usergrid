{
  final int totalCount=10000000;
  final int delta=Character.MAX_CODE_POINT - Character.MIN_CODE_POINT;
  final int lengthToTest=totalCount / delta;
  final HashMultimap<EdgeHasher.HashEdge,String> hashed=HashMultimap.create(totalCount,2);
  char[] chars;
  EdgeHasher.HashEdge uuidHash;
  StringBuilder builder=new StringBuilder();
  for (int index=0; index < lengthToTest; index++) {
    builder.append('a');
    for (int charValue=Character.MIN_CODE_POINT; charValue <= Character.MAX_CODE_POINT; charValue++) {
      chars=Character.toChars(charValue);
      if (chars.length > 1) {
        continue;
      }
      builder.setCharAt(index,chars[0]);
      final String sourceString=builder.toString();
      uuidHash=EdgeHasher.createEdgeHash(sourceString);
      hashed.put(uuidHash,sourceString);
      final Set<String> strings=hashed.get(uuidHash);
      if (strings.size() > 1) {
        if (assertSameStrings(strings)) {
          continue;
        }
        final EdgeHasher.HashEdge uuid=uuidHash;
        final String value=builder.toString();
        String error=String.format("Expected hash of '%s' to be unique, but hash of '%s' already exists.  Existing values " + "are: '",value,uuid);
        for (        String input : hashed.get(uuid)) {
          error+=input + ", ";
        }
        error=error.substring(0,error.length() - 1).concat("'");
        fail(error);
      }
    }
  }
  assertEquals("Check the sizes are equal",totalCount,hashed.size());
}
