{
  final UUID now=UUIDGenerator.newTimeUUID();
  List<UUID> maxShards=getShards(scope,nodeId,MAX_UUID,1,edgeType);
  if (maxShards.size() > 0 && UUIDComparator.staticCompare(now,maxShards.get(0)) < 0) {
    return false;
  }
  final UUID futureUUID=UUIDGenerator.newTimeUUID();
  try {
    this.edgeSeriesSerialization.writeEdgeMeta(scope,nodeId,futureUUID,edgeType).execute();
  }
 catch (  ConnectionException e) {
    throw new RuntimeException("Unable to write the new edge metadata");
  }
  UUID max=null;
  MutationBatch rollup=null;
  boolean completed=false;
  while (!completed) {
    List<UUID> shards=getShards(scope,nodeId,MAX_UUID,100,edgeType);
    for (    UUID shardId : shards) {
      if (UUIDComparator.staticCompare(shardId,max) >= 0) {
        completed=true;
        break;
      }
      final MutationBatch batch=edgeSeriesSerialization.removeEdgeMeta(scope,nodeId,shardId,edgeType);
      if (rollup == null) {
        rollup=batch;
      }
 else {
        rollup.mergeShallow(batch);
      }
    }
  }
  if (rollup != null) {
    try {
      rollup.execute();
    }
 catch (    ConnectionException e) {
      throw new RuntimeException("Unable to cleanup allocated shards");
    }
  }
  return true;
}
