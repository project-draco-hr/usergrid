{
  int consumerSize=8;
  int count=10000;
  int batchsize=100;
  ExecutorService executor=Executors.newFixedThreadPool(consumerSize);
  TestAdminUser testAdmin=new TestAdminUser("queueresourcetest.concurrentConsumers","queueresourcetest.concurrentConsumers@usergrid.com","queueresourcetest.concurrentConsumers@usergrid.com");
  TestContext context=TestContext.create(this).withOrg("queueresourcetest.concurrentConsumers").withApp("concurrentConsumers").withUser(testAdmin).initAll();
  Queue queue=context.application().queues().queue("test");
  for (int i=0; i < count / batchsize; i++) {
    @SuppressWarnings("unchecked") Map<String,?>[] elements=new Map[batchsize];
    for (int j=0; j < batchsize; j++) {
      elements[j]=MapUtils.hashMap("id",i * batchsize + j);
    }
    queue.post(elements);
  }
  final long timeout=120000;
  queue=queue.withTimeout(timeout).withNext(20);
  AsyncTransactionResponseHandler transHandler=new AsyncTransactionResponseHandler(count);
  NoLastCommand command=new NoLastCommand();
  List<Future<Void>> futures=new ArrayList<Future<Void>>(consumerSize);
  for (int i=0; i < consumerSize; i++) {
    Future<Void> future=executor.submit(new QueueClient(queue,transHandler,command));
    futures.add(future);
  }
  for (  Future<Void> future : futures) {
    future.get();
  }
  transHandler.assertResults();
}
