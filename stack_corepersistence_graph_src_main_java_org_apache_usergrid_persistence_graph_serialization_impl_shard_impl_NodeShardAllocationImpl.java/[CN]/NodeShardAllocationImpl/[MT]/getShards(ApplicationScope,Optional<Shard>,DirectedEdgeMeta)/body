{
  ValidationUtils.validateApplicationScope(scope);
  Preconditions.checkNotNull(maxShardId,"maxShardId cannot be null");
  GraphValidation.validateDirectedEdgeMeta(directedEdgeMeta);
  Iterator<Shard> existingShards;
  if (isNewNode(directedEdgeMeta)) {
    existingShards=Collections.singleton(MIN_SHARD).iterator();
  }
 else {
    existingShards=edgeShardSerialization.getShardMetaData(scope,maxShardId,directedEdgeMeta);
  }
  if (existingShards == null || !existingShards.hasNext()) {
    try {
      edgeShardSerialization.writeShardMeta(scope,MIN_SHARD,directedEdgeMeta).execute();
    }
 catch (    ConnectionException e) {
      throw new GraphRuntimeException("Unable to allocate minimum shard");
    }
    existingShards=Collections.singleton(MIN_SHARD).iterator();
  }
  return new ShardEntryGroupIterator(existingShards,graphFig.getShardMinDelta());
}
