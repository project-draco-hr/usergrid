{
  if (!readyToProduce()) {
    return;
  }
synchronized (this) {
    while (true) {
      InnerObserver<T> maxObserver=null;
      T max=null;
      for (      InnerObserver<T> inner : innerSubscribers) {
        if (inner.drained) {
          continue;
        }
        final T current=inner.peek();
        if (current == null) {
          return;
        }
        if (max == null || (current != null && comparator.compare(current,max) > 0)) {
          maxObserver=inner;
          max=current;
        }
      }
      if (maxObserver == null) {
        return;
      }
      subscriber.onNext(maxObserver.pop());
    }
  }
}
