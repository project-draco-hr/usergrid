{
  List<EntityLocationRef> entityLocations=new ArrayList<EntityLocationRef>(maxResults);
  List<String> curGeocells=new ArrayList<String>();
  String curContainingGeocell=null;
  if (geoCells != null && geoCells.size() > 0) {
    curGeocells.addAll(geoCells);
    curContainingGeocell=geoCells.get(0);
  }
 else {
    curContainingGeocell=GeocellUtils.compute(searchPoint,MAX_GEOCELL_RESOLUTION);
    curGeocells.add(curContainingGeocell);
  }
  if (minMatch != null) {
    minMatch.calcDistance(searchPoint);
  }
  Set<String> searchedCells=new HashSet<String>();
  List<String> curGeocellsUnique=null;
  double closestPossibleNextResultDist=0;
  int noDirection[]={0,0};
  List<Tuple<int[],Double>> sortedEdgesDistances=Arrays.asList(new Tuple<int[],Double>(noDirection,0d));
  boolean done=false;
  UUID lastReturned=null;
  while (!curGeocells.isEmpty() && entityLocations.size() < maxResults) {
    closestPossibleNextResultDist=sortedEdgesDistances.get(0).getSecond();
    if (maxDistance > 0 && closestPossibleNextResultDist > maxDistance) {
      break;
    }
    Set<String> curTempUnique=new HashSet<String>(curGeocells);
    curTempUnique.removeAll(searchedCells);
    curGeocellsUnique=new ArrayList<String>(curTempUnique);
    Set<HColumn<ByteBuffer,ByteBuffer>> queryResults=null;
    lastReturned=null;
    do {
      queryResults=doSearch(curGeocellsUnique,lastReturned,searchPoint,propertyName,MAX_FETCH_SIZE);
      if (logger.isDebugEnabled()) {
        logger.debug("fetch complete for: {}",StringUtils.join(curGeocellsUnique,", "));
      }
      searchedCells.addAll(curGeocells);
      for (      HColumn<ByteBuffer,ByteBuffer> column : queryResults) {
        DynamicComposite composite=DynamicComposite.fromByteBuffer(column.getName());
        UUID uuid=composite.get(0,UUIDSerializer.get());
        lastReturned=uuid;
        String type=composite.get(1,StringSerializer.get());
        UUID timestampUuid=composite.get(2,UUIDSerializer.get());
        composite=DynamicComposite.fromByteBuffer(column.getValue());
        Double latitude=composite.get(0,DoubleSerializer.get());
        Double longitude=composite.get(1,DoubleSerializer.get());
        EntityLocationRef entityLocation=new EntityLocationRef(type,uuid,timestampUuid,latitude,longitude);
        double distance=entityLocation.calcDistance(searchPoint);
        if (distance < minDistance || (maxDistance != 0 && distance > maxDistance) || (minMatch != null && COMP.compare(entityLocation,minMatch) <= 0)) {
          continue;
        }
        int index=Collections.binarySearch(entityLocations,entityLocation,COMP);
        if (index > -1) {
          continue;
        }
        index=(index + 1) * -1;
        if (index >= maxResults) {
          continue;
        }
        entityLocations.add(index,entityLocation);
        while (entityLocations.size() > maxResults) {
          entityLocations.remove(entityLocations.size() - 1);
        }
      }
    }
 while (queryResults != null && queryResults.size() == MAX_FETCH_SIZE);
    if (done || entityLocations.size() == maxResults) {
      break;
    }
    sortedEdgesDistances=GeocellUtils.distanceSortedEdges(curGeocells,searchPoint);
    if (queryResults.size() == 0 || curGeocells.size() == 4) {
      curContainingGeocell=curContainingGeocell.substring(0,Math.max(curContainingGeocell.length() - 1,0));
      if (curContainingGeocell.length() == 0) {
        curGeocells.clear();
        String[] items="0123456789abcdef".split("(?!^)");
        for (        String item : items)         curGeocells.add(item);
        done=true;
      }
 else {
        List<String> oldCurGeocells=new ArrayList<String>(curGeocells);
        curGeocells.clear();
        for (        String cell : oldCurGeocells) {
          if (cell.length() > 0) {
            String newCell=cell.substring(0,cell.length() - 1);
            if (!curGeocells.contains(newCell)) {
              curGeocells.add(newCell);
            }
          }
        }
      }
    }
 else     if (curGeocells.size() == 1) {
      for (int i=0; i < sortedEdgesDistances.size(); i++) {
        int nearestEdge[]=sortedEdgesDistances.get(i).getFirst();
        String edge=GeocellUtils.adjacent(curGeocells.get(0),nearestEdge);
        if (edge == null) {
          continue;
        }
        curGeocells.add(edge);
        break;
      }
    }
 else     if (curGeocells.size() == 2) {
      int nearestEdge[]=GeocellUtils.distanceSortedEdges(Arrays.asList(curContainingGeocell),searchPoint).get(0).getFirst();
      int[] perpendicularNearestEdge={0,0};
      if (nearestEdge[0] == 0) {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] != 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
 else {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] == 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
      List<String> tempCells=new ArrayList<String>();
      for (      String cell : curGeocells) {
        tempCells.add(GeocellUtils.adjacent(cell,perpendicularNearestEdge));
      }
      curGeocells.addAll(tempCells);
    }
    logger.debug("{} results found.",entityLocations.size());
  }
  return new SearchResults(entityLocations,curGeocells);
}
