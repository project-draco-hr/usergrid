{
  final BlockingObservable<Long> uniqueValueCleanup=Observable.create(new ObservableIterator<UniqueValue>("Unique value load"){
    @Override protected Iterator<UniqueValue> getIterator(){
      return uniqueValueSerializationStrategy.getAllUniqueFields(scope,entityId);
    }
  }
).skipWhile(new Func1<UniqueValue,Boolean>(){
    @Override public Boolean call(    final UniqueValue uniqueValue){
      return version.equals(uniqueValue.getEntityVersion());
    }
  }
).buffer(serializationFig.getBufferSize()).doOnNext(new Action1<List<UniqueValue>>(){
    @Override public void call(    final List<UniqueValue> uniqueValues){
      final MutationBatch uniqueCleanupBatch=keyspace.prepareMutationBatch();
      for (      UniqueValue value : uniqueValues) {
        uniqueCleanupBatch.mergeShallow(uniqueValueSerializationStrategy.delete(scope,value));
      }
      try {
        uniqueCleanupBatch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to execute batch mutation",e);
      }
    }
  }
).subscribeOn(Schedulers.io()).longCount().toBlocking();
  BlockingObservable<Long> versionsDeletedObservable=Observable.create(new ObservableIterator<MvccLogEntry>("Log entry iterator"){
    @Override protected Iterator<MvccLogEntry> getIterator(){
      return new LogEntryIterator(logEntrySerializationStrategy,scope,entityId,version,serializationFig.getBufferSize());
    }
  }
).skipWhile(new Func1<MvccLogEntry,Boolean>(){
    @Override public Boolean call(    final MvccLogEntry mvccLogEntry){
      return version.equals(mvccLogEntry.getVersion());
    }
  }
).buffer(serializationFig.getBufferSize()).doOnNext(new Action1<List<MvccLogEntry>>(){
    @Override public void call(    final List<MvccLogEntry> mvccEntities){
      fireEvents(mvccEntities);
      final MutationBatch logCleanupBatch=keyspace.prepareMutationBatch();
      for (      MvccLogEntry entry : mvccEntities) {
        logCleanupBatch.mergeShallow(logEntrySerializationStrategy.delete(scope,entityId,entry.getVersion()));
      }
      try {
        logCleanupBatch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to execute batch mutation",e);
      }
    }
  }
).subscribeOn(Schedulers.io()).longCount().toBlocking();
  final Long removedCount=uniqueValueCleanup.last();
  logger.debug("Removed unique values for {} entities of entity {}",removedCount,entityId);
  final Long versionCleanupCount=versionsDeletedObservable.last();
  logger.debug("Removed {} previous entity versions of entity {}",versionCleanupCount,entityId);
  return null;
}
