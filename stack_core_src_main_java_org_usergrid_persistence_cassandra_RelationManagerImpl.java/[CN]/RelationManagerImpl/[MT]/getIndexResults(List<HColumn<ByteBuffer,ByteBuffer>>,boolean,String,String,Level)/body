{
  if (results == null) {
    return null;
  }
  Set<UUID> idSet=new LinkedHashSet<UUID>();
  List<UUID> ids=null;
  List<EntityRef> refs=null;
  Map<UUID,Map<String,Object>> metadata=new LinkedHashMap<UUID,Map<String,Object>>();
  if (level.ordinal() > REFS.ordinal()) {
    level=REFS;
  }
  if (compositeResults && (level != IDS)) {
    refs=new ArrayList<EntityRef>();
  }
 else {
    ids=new ArrayList<UUID>();
  }
  for (  HColumn<ByteBuffer,ByteBuffer> result : results) {
    UUID connectedEntityId=null;
    String cType=connectionType;
    String eType=entityType;
    UUID associatedEntityId=null;
    if (compositeResults) {
      List<Object> objects=DynamicComposite.fromByteBuffer(result.getName().duplicate());
      connectedEntityId=(UUID)objects.get(2);
      if (refs != null) {
        if ((connectionType == null) || (entityType == null)) {
          if (connectionType != null) {
            eType=StringUtils.ifString(objects.get(3));
          }
 else           if (entityType != null) {
            cType=StringUtils.ifString(objects.get(3));
          }
 else {
            cType=StringUtils.ifString(objects.get(3));
            eType=StringUtils.ifString(objects.get(4));
          }
        }
      }
    }
 else {
      connectedEntityId=uuid(result.getName());
    }
    ByteBuffer v=result.getValue();
    if ((v != null) && (v.remaining() >= 16)) {
      associatedEntityId=uuid(result.getValue());
    }
    if ((refs != null) && (eType != null)) {
      if (!idSet.contains(connectedEntityId)) {
        refs.add(new SimpleEntityRef(eType,connectedEntityId));
        idSet.add(connectedEntityId);
      }
 else {
        logger.error("Duplicate entity uuid (" + connectedEntityId + ") found in index results, discarding but index appears inconsistent...");
      }
    }
    if (ids != null) {
      if (!idSet.contains(connectedEntityId)) {
        ids.add(connectedEntityId);
        idSet.add(connectedEntityId);
      }
 else {
        logger.error("Duplicate entity uuid ({}) found in index results, discarding but index appears inconsistent...",connectedEntityId);
      }
    }
    if (cType != null) {
      MapUtils.putMapMap(metadata,connectedEntityId,PROPERTY_CONNECTION,cType);
    }
    String cursor=encodeBase64URLSafeString(bytes(result.getName()));
    if (cursor != null) {
      MapUtils.putMapMap(metadata,connectedEntityId,PROPERTY_CURSOR,cursor);
    }
    if (associatedEntityId != null) {
      MapUtils.putMapMap(metadata,connectedEntityId,PROPERTY_ASSOCIATED,associatedEntityId);
    }
  }
  Results r=null;
  if ((refs != null) && (refs.size() > 0)) {
    r=fromRefList(refs);
  }
 else   if ((ids != null) && (ids.size() > 0)) {
    r=fromIdList(ids);
  }
 else {
    r=new Results();
  }
  if (metadata.size() > 0) {
    r.setMetadata(metadata);
  }
  return r;
}
