{
  Object start=getStart(slice);
  Object finish=getFinish(slice);
  if (slice.isReversed() && (start != null) && (finish != null)) {
    Object temp=start;
    start=finish;
    finish=temp;
  }
  List<String> keys=indexBucketLocator.getBuckets(applicationId,collectionName);
  List<Object> cassKeys=new ArrayList<Object>(keys.size());
  for (  String bucket : keys) {
    cassKeys.add(key(indexKey,slice.getPropertyName(),bucket));
  }
  Map<ByteBuffer,List<HColumn<ByteBuffer,ByteBuffer>>> results=cass.multiGetColumns(cass.getApplicationKeyspace(applicationId),ENTITY_INDEX,cassKeys,start,finish,count,slice.isReversed());
  final Comparator<ByteBuffer> comparator=slice.isReversed() ? reverseComparator : forwardComparator;
  TreeSet<HColumn<ByteBuffer,ByteBuffer>> resultsTree=new TreeSet<HColumn<ByteBuffer,ByteBuffer>>(new Comparator<HColumn<ByteBuffer,ByteBuffer>>(){
    @Override public int compare(    HColumn<ByteBuffer,ByteBuffer> first,    HColumn<ByteBuffer,ByteBuffer> second){
      return comparator.compare(first.getName(),second.getName());
    }
  }
);
  for (  List<HColumn<ByteBuffer,ByteBuffer>> cols : results.values()) {
    for (    HColumn<ByteBuffer,ByteBuffer> col : cols) {
      resultsTree.add(col);
      if (resultsTree.size() > count) {
        resultsTree.remove(resultsTree.last());
      }
    }
  }
  return new ArrayList<HColumn<ByteBuffer,ByteBuffer>>(resultsTree);
}
