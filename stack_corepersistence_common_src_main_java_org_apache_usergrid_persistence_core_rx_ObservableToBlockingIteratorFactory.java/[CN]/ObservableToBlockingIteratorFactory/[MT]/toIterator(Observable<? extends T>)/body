{
  final BlockingQueue<Notification<? extends T>> notifications=new ArrayBlockingQueue<>(1);
  final Subscription subscription=source.materialize().subscribe(new Subscriber<Notification<? extends T>>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      try {
        notifications.put(Notification.<T>createOnError(e));
      }
 catch (      Exception t) {
      }
    }
    @Override public void onNext(    Notification<? extends T> args){
      try {
        notifications.put(args);
      }
 catch (      Exception t) {
      }
    }
  }
);
  return new Iterator<T>(){
    private Notification<? extends T> buf;
    @Override public boolean hasNext(){
      if (buf == null) {
        buf=take();
      }
      if (buf.isOnError()) {
        throw Exceptions.propagate(buf.getThrowable());
      }
      return !buf.isOnCompleted();
    }
    @Override public T next(){
      if (hasNext()) {
        T result=buf.getValue();
        buf=null;
        return result;
      }
      throw new NoSuchElementException();
    }
    private Notification<? extends T> take(){
      try {
        return notifications.take();
      }
 catch (      InterruptedException e) {
        subscription.unsubscribe();
        throw Exceptions.propagate(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException("Read-only iterator");
    }
  }
;
}
