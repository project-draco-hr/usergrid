{
  Preconditions.checkNotNull(entityId,"entityId cannot be null");
  Preconditions.checkNotNull(markedVersion,"markedVersion cannot be null");
  ValidationUtils.verifyVersion(markedVersion);
  SearchResponse searchResponse;
  List<CandidateResult> candidates=new ArrayList<>();
  final long markedTimestamp=markedVersion.timestamp();
  final int searchLimit=Math.max(2,indexFig.getVersionQueryLimit());
  final QueryBuilder entityQuery=QueryBuilders.termQuery(IndexingUtils.ENTITY_ID_FIELDNAME,IndexingUtils.entityId(entityId));
  final QueryBuilder nodeQuery=QueryBuilders.termQuery(IndexingUtils.EDGE_NODE_ID_FIELDNAME,IndexingUtils.nodeId(entityId));
  final SearchRequestBuilder srb=searchRequestBuilderStrategyV2.getBuilder().addSort(IndexingUtils.EDGE_TIMESTAMP_FIELDNAME,SortOrder.ASC);
  try {
    long queryTimestamp=0L;
    while (true) {
      QueryBuilder timestampQuery=QueryBuilders.rangeQuery(IndexingUtils.EDGE_TIMESTAMP_FIELDNAME).gte(queryTimestamp).lte(markedTimestamp);
      QueryBuilder entityQueryWithTimestamp=QueryBuilders.boolQuery().must(entityQuery).must(timestampQuery);
      QueryBuilder finalQuery=QueryBuilders.boolQuery().should(entityQueryWithTimestamp).should(nodeQuery).minimumNumberShouldMatch(1);
      searchResponse=srb.setQuery(finalQuery).setSize(searchLimit).execute().actionGet();
      int responseSize=searchResponse.getHits().getHits().length;
      if (responseSize == 0) {
        break;
      }
      candidates=aggregateScrollResults(candidates,searchResponse,markedVersion);
      queryTimestamp=(long)searchResponse.getHits().getAt(responseSize - 1).getSource().get(IndexingUtils.EDGE_TIMESTAMP_FIELDNAME);
      if (responseSize < searchLimit) {
        break;
      }
    }
  }
 catch (  Throwable t) {
    logger.error("Unable to communicate with Elasticsearch",t.getMessage());
    failureMonitor.fail("Unable to execute batch",t);
    throw t;
  }
  failureMonitor.success();
  return new CandidateResults(candidates,Collections.EMPTY_SET);
}
