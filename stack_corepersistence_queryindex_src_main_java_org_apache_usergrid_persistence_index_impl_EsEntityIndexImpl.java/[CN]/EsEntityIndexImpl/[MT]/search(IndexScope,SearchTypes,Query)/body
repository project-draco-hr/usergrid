{
  final String context=IndexingUtils.createContextName(indexScope);
  final String[] entityTypes=searchTypes.getTypeNames();
  QueryBuilder qb=query.createQueryBuilder(context);
  SearchResponse searchResponse;
  if (query.getCursor() == null) {
    SearchRequestBuilder srb=esProvider.getClient().prepareSearch(alias.getReadAlias()).setTypes(entityTypes).setScroll(cursorTimeout + "m").setQuery(qb);
    final FilterBuilder fb=query.createFilterBuilder();
    if (fb != null) {
      logger.debug("   Filter: {} ",fb.toString());
      srb=srb.setPostFilter(fb);
    }
    srb=srb.setFrom(0).setSize(query.getLimit());
    for (    Query.SortPredicate sp : query.getSortPredicates()) {
      final SortOrder order;
      if (sp.getDirection().equals(Query.SortDirection.ASCENDING)) {
        order=SortOrder.ASC;
      }
 else {
        order=SortOrder.DESC;
      }
      final String stringFieldName=STRING_PREFIX + sp.getPropertyName();
      final FieldSortBuilder stringSort=SortBuilders.fieldSort(stringFieldName).order(order).ignoreUnmapped(true);
      srb.addSort(stringSort);
      logger.debug("   Sort: {} order by {}",stringFieldName,order.toString());
      final String numberFieldName=NUMBER_PREFIX + sp.getPropertyName();
      final FieldSortBuilder numberSort=SortBuilders.fieldSort(numberFieldName).order(order).ignoreUnmapped(true);
      srb.addSort(numberSort);
      logger.debug("   Sort: {} order by {}",numberFieldName,order.toString());
      final String booleanFieldName=BOOLEAN_PREFIX + sp.getPropertyName();
      final FieldSortBuilder booleanSort=SortBuilders.fieldSort(booleanFieldName).order(order).ignoreUnmapped(true);
      srb.addSort(booleanSort);
      logger.debug("   Sort: {} order by {}",booleanFieldName,order.toString());
    }
    if (logger.isDebugEnabled()) {
      logger.debug("Searching index (read alias): {}\n  scope: {} \n type: {}\n   query: {} ",this.alias.getReadAlias(),context,entityTypes,srb);
    }
    try {
      Timer.Context timeSearch=searchTimer.time();
      searchResponse=srb.execute().actionGet();
      timeSearch.stop();
    }
 catch (    Throwable t) {
      logger.error("Unable to communicate with Elasticsearch",t);
      failureMonitor.fail("Unable to execute batch",t);
      throw t;
    }
    failureMonitor.success();
  }
 else {
    String userCursorString=query.getCursor();
    if (userCursorString.startsWith("\"")) {
      userCursorString=userCursorString.substring(1);
    }
    if (userCursorString.endsWith("\"")) {
      userCursorString=userCursorString.substring(0,userCursorString.length() - 1);
    }
    final String esScrollCursor=mapManager.getString(userCursorString);
    Preconditions.checkArgument(esScrollCursor != null,"Could not find a cursor for the value '{}' ",esScrollCursor);
    logger.debug("Executing query with cursor: {} ",esScrollCursor);
    SearchScrollRequestBuilder ssrb=esProvider.getClient().prepareSearchScroll(esScrollCursor).setScroll(cursorTimeout + "m");
    try {
      Timer.Context timeSearchCursor=cursorTimer.time();
      searchResponse=ssrb.execute().actionGet(config.getElasticsearchQueryTimeout());
      timeSearchCursor.stop();
    }
 catch (    Throwable t) {
      logger.error("Unable to communicate with elasticsearch",t);
      failureMonitor.fail("Unable to execute batch",t);
      throw t;
    }
    failureMonitor.success();
  }
  return parseResults(searchResponse,query);
}
