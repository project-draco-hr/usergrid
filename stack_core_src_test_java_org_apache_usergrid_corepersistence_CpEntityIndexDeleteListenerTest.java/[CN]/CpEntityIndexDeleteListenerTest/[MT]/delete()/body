{
  CollectionScope scope=mock(CollectionScope.class);
  UUID uuid=TimeUUIDUtils.getTimeUUID(10000L);
  Id entityId=new SimpleId(uuid,"test");
  CandidateResult entity=mock(CandidateResult.class);
  when(entity.getVersion()).thenReturn(uuid);
  when(entity.getId()).thenReturn(entityId);
  when(scope.getOwner()).thenReturn(entityId);
  when(scope.getName()).thenReturn("test");
  when(scope.getApplication()).thenReturn(entityId);
  when(eif.createEntityIndex(any(ApplicationScope.class))).thenReturn(entityIndex);
  final EntityIndexBatch batch=mock(EntityIndexBatch.class);
  when(entityIndex.createBatch()).thenReturn(batch);
  CandidateResults results=mock(CandidateResults.class);
  List<CandidateResult> resultsList=new ArrayList<>();
  resultsList.add(entity);
  Iterator<CandidateResult> entities=resultsList.iterator();
  when(results.iterator()).thenReturn(entities);
  when(serializationFig.getBufferSize()).thenReturn(10);
  when(serializationFig.getHistorySize()).thenReturn(20);
  when(entityIndex.getEntityVersions(any(IndexScope.class),entityId)).thenReturn(results);
  MvccEntity mvccEntity=new MvccEntityImpl(entityId,uuid,MvccEntity.Status.COMPLETE,mock(Entity.class));
  MvccEntityDeleteEvent event=new MvccEntityDeleteEvent(scope,uuid,mvccEntity);
  Observable<EntityVersion> o=esEntityIndexDeleteListener.receive(event);
  EntityVersion testEntity=o.toBlocking().last();
  assertEquals(testEntity.getId(),mvccEntity.getId());
  verify(entityIndex).createBatch();
  verify(batch).deindex(any(IndexScope.class),entity.getId(),entity.getVersion());
}
