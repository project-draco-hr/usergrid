{
  final EdgeSeriesSerialization edgeSeriesSerialization=mock(EdgeSeriesSerialization.class);
  final EdgeSeriesCounterSerialization edgeSeriesCounterSerialization=mock(EdgeSeriesCounterSerialization.class);
  final TimeService timeService=mock(TimeService.class);
  final Keyspace keyspace=mock(Keyspace.class);
  final MutationBatch batch=mock(MutationBatch.class);
  when(keyspace.prepareMutationBatch()).thenReturn(batch);
  NodeShardAllocation approximation=new NodeShardAllocationImpl(edgeSeriesSerialization,edgeSeriesCounterSerialization,timeService,graphFig,keyspace);
  final Id nodeId=createId("test");
  final String type="type";
  final String subType="subType";
  final long timeservicetime=System.currentTimeMillis();
  when(timeService.getCurrentTime()).thenReturn(timeservicetime);
  when(edgeSeriesSerialization.getEdgeMetaData(same(scope),same(nodeId),any(UUID.class),eq(1),same(type),same(subType))).thenReturn(Arrays.asList(Constants.MIN_UUID).iterator());
  final long shardCount=graphFig.getShardSize();
  when(edgeSeriesCounterSerialization.getCount(same(scope),same(nodeId),eq(Constants.MIN_UUID),same(type),same(subType))).thenReturn(shardCount);
  ArgumentCaptor<UUID> newUUIDValue=ArgumentCaptor.forClass(UUID.class);
  when(edgeSeriesSerialization.writeEdgeMeta(same(scope),same(nodeId),newUUIDValue.capture(),same(type),same(subType))).thenReturn(mock(MutationBatch.class));
  final boolean result=approximation.auditMaxShard(scope,nodeId,type,subType);
  assertTrue("Shard allocated",result);
  final long expectedUUIDTime=timeservicetime + 2 * graphFig.getShardCacheTimeout();
  UUID expectedUUID=UUIDGenerator.newTimeUUID(expectedUUIDTime);
  final int comparison=UUIDComparator.staticCompare(expectedUUID,newUUIDValue.getValue());
  final long expectedTimestamp=expectedUUID.timestamp() / 10000;
  final long savedTimestamp=newUUIDValue.getValue().timestamp() / 10000;
  assertEquals("Expected UUID at 2x timeout generated",expectedTimestamp,savedTimestamp);
}
