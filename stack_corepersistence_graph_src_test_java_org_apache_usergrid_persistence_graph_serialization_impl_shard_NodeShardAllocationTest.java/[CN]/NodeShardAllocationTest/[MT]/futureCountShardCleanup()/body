{
  final ShardGroupCompaction shardGroupCompaction=mock(ShardGroupCompaction.class);
  final EdgeShardSerialization edgeShardSerialization=mock(EdgeShardSerialization.class);
  final EdgeColumnFamilies edgeColumnFamilies=mock(EdgeColumnFamilies.class);
  final ShardedEdgeSerialization shardedEdgeSerialization=mock(ShardedEdgeSerialization.class);
  final NodeShardApproximation nodeShardApproximation=mock(NodeShardApproximation.class);
  final TimeService timeService=mock(TimeService.class);
  NodeShardAllocation approximation=new NodeShardAllocationImpl(edgeShardSerialization,edgeColumnFamilies,shardedEdgeSerialization,nodeShardApproximation,timeService,graphFig,shardGroupCompaction);
  final Id nodeId=createId("test");
  final String type="type";
  final String subType="subType";
  final long timeservicetime=System.currentTimeMillis() + 60000;
  when(timeService.getCurrentTime()).thenReturn(timeservicetime);
  assertTrue("Shard cache mocked",graphFig.getShardCacheTimeout() > 0);
  final long minDelta=graphFig.getShardMinDelta();
  final Shard minShard=new Shard(0l,0l,true);
  final Shard compactedShard=new Shard(5000,1000,true);
  final long minTime=10000;
  final Shard futureShard1=new Shard(10000,minTime + minDelta,false);
  final Shard futureShard2=new Shard(10005,minTime,false);
  final Shard futureShard3=new Shard(10010,minTime + minDelta / 2,false);
  final DirectedEdgeMeta directedEdgeMeta=DirectedEdgeMeta.fromTargetNodeSourceType(nodeId,type,subType);
  when(edgeShardSerialization.getShardMetaData(same(scope),any(Optional.class),same(directedEdgeMeta))).thenReturn(Arrays.asList(futureShard3,futureShard2,futureShard1,compactedShard,minShard).iterator());
  ArgumentCaptor<Shard> newLongValue=ArgumentCaptor.forClass(Shard.class);
  when(edgeShardSerialization.removeShardMeta(same(scope),newLongValue.capture(),same(directedEdgeMeta))).thenReturn(mock(MutationBatch.class));
  final Iterator<ShardEntryGroup> result=approximation.getShards(scope,Optional.<Shard>absent(),directedEdgeMeta);
  assertTrue("Shards present",result.hasNext());
  ShardEntryGroup shardEntryGroup=result.next();
  assertEquals("Future shard returned",futureShard1,shardEntryGroup.getCompactionTarget());
  Collection<Shard> writeShards=shardEntryGroup.getWriteShards(minTime + minDelta);
  assertEquals("Shard size as expected",1,writeShards.size());
  assertTrue(writeShards.contains(compactedShard));
  Collection<Shard> readShards=shardEntryGroup.getReadShards();
  assertEquals("Shard size as expected",2,readShards.size());
  assertTrue(readShards.contains(futureShard1));
  assertTrue(readShards.contains(compactedShard));
  assertTrue("Shards present",result.hasNext());
  shardEntryGroup=result.next();
  writeShards=shardEntryGroup.getWriteShards(minTime + minDelta);
  assertTrue("Previous shard present",writeShards.contains(minShard));
  writeShards=shardEntryGroup.getReadShards();
  assertTrue("Previous shard present",writeShards.contains(minShard));
  assertFalse("No shards left",result.hasNext());
}
