{
  LOG.info("sending batch of {} notifications.",messages.size());
  final Meter sendMeter=metricsFactory.getMeter(NotificationsService.class,"send");
  final Map<Object,Notifier> notifierMap=getNotifierMap();
  final QueueManager proxy=this;
  final ConcurrentHashMap<UUID,SingleQueueTaskManager> taskMap=new ConcurrentHashMap<UUID,SingleQueueTaskManager>(messages.size());
  final ConcurrentHashMap<UUID,Notification> notificationMap=new ConcurrentHashMap<UUID,Notification>(messages.size());
  final Func1<ApplicationQueueMessage,ApplicationQueueMessage> func=new Func1<ApplicationQueueMessage,ApplicationQueueMessage>(){
    @Override public ApplicationQueueMessage call(    ApplicationQueueMessage message){
      try {
        LOG.info("start sending notification for device {} for Notification: {} on thread " + Thread.currentThread().getId(),message.getDeviceId(),message.getNotificationId());
        UUID deviceUUID=message.getDeviceId();
        Notification notification=notificationMap.get(message.getNotificationId());
        if (notification == null) {
          notification=em.get(message.getNotificationId(),Notification.class);
          notificationMap.put(message.getNotificationId(),notification);
        }
        SingleQueueTaskManager taskManager;
synchronized (taskMap) {
          taskManager=taskMap.get(message.getNotificationId());
          if (taskManager == null) {
            taskManager=new SingleQueueTaskManager(em,qm,proxy,notification);
            taskMap.put(message.getNotificationId(),taskManager);
          }
        }
        final Map<String,Object> payloads=notification.getPayloads();
        final Map<String,Object> translatedPayloads=translatePayloads(payloads,notifierMap);
        LOG.info("sending notification for device {} for Notification: {}",deviceUUID,notification.getUuid());
        if (!isOkToSend(notification)) {
          return message;
        }
        taskManager.addMessage(deviceUUID,message);
        try {
          String notifierName=message.getNotifierKey().toLowerCase();
          Notifier notifier=notifierMap.get(notifierName.toLowerCase());
          Object payload=translatedPayloads.get(notifierName);
          Receipt receipt=new Receipt(notification.getUuid(),message.getNotifierId(),payload,deviceUUID);
          TaskTracker tracker=new TaskTracker(notifier,taskManager,receipt,deviceUUID);
          if (payload == null) {
            LOG.debug("selected device {} for notification {} doesn't have a valid payload. skipping.",deviceUUID,notification.getUuid());
            tracker.failed(0,"failed to match payload to " + message.getNotifierId() + " notifier");
          }
 else {
            try {
              ProviderAdapter providerAdapter=providerAdapters.get(notifier.getProvider());
              providerAdapter.sendNotification(message.getNotifierId(),notifier,payload,notification,tracker);
            }
 catch (            Exception e) {
              tracker.failed(0,e.getMessage());
            }
          }
        }
  finally {
          sendMeter.mark();
        }
      }
 catch (      Exception e) {
        LOG.error("Failure unknown",e);
      }
      return message;
    }
  }
;
  Observable o=rx.Observable.from(messages).subscribeOn(Schedulers.io()).map(func).buffer(BATCH_SIZE).map(new Func1<List<ApplicationQueueMessage>,HashMap<UUID,ApplicationQueueMessage>>(){
    @Override public HashMap<UUID,ApplicationQueueMessage> call(    List<ApplicationQueueMessage> queueMessages){
      for (      ProviderAdapter providerAdapter : providerAdapters.values()) {
        try {
          providerAdapter.doneSendingNotifications();
        }
 catch (        Exception e) {
          LOG.error("providerAdapter.doneSendingNotifications: ",e);
        }
      }
      HashMap<UUID,ApplicationQueueMessage> notifications=new HashMap<UUID,ApplicationQueueMessage>();
      for (      ApplicationQueueMessage message : queueMessages) {
        if (notifications.get(message.getNotificationId()) == null) {
          try {
            SingleQueueTaskManager taskManager=taskMap.get(message.getNotificationId());
            notifications.put(message.getNotificationId(),message);
            taskManager.finishedBatch();
          }
 catch (          Exception e) {
            LOG.error("Failed to finish batch",e);
          }
        }
      }
      return notifications;
    }
  }
).doOnError(new Action1<Throwable>(){
    @Override public void call(    Throwable throwable){
      LOG.error("Failed while sending",throwable);
    }
  }
);
  return o;
}
