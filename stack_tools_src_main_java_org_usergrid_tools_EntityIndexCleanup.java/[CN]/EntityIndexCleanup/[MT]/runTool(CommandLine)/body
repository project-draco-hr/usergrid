{
  startSpring();
  logger.info("Starting entity cleanup");
  List<UUID> ids=null;
  Query query=new Query();
  query.setLimit(PAGE_SIZE);
  String lastCursor=null;
  for (  Entry<String,UUID> app : emf.getApplications().entrySet()) {
    logger.info("Starting cleanup for app {}",app.getKey());
    UUID applicationId=app.getValue();
    EntityManagerImpl em=(EntityManagerImpl)emf.getEntityManager(applicationId);
    CassandraService cass=em.getCass();
    IndexBucketLocator indexBucketLocator=em.getIndexBucketLocator();
    Keyspace ko=cass.getApplicationKeyspace(applicationId);
    UUID timestampUuid=newTimeUUID();
    long timestamp=getTimestampInMicros(timestampUuid);
    Set<String> collectionNames=em.getApplicationCollections();
    for (    String collectionName : collectionNames) {
      do {
        query.setCursor(lastCursor);
        ids=cass.getIdList(cass.getApplicationKeyspace(applicationId),key(applicationId,DICTIONARY_COLLECTIONS,collectionName),query.getStartResult(),null,query.getLimit() + 1,false,indexBucketLocator,applicationId,collectionName);
        CollectionInfo collection=getDefaultSchema().getCollection("application",collectionName);
        Results tempResults=Results.fromIdList(ids);
        tempResults.trim(query.getLimit());
        lastCursor=tempResults.getCursor();
        Set<String> indexed=collection.getPropertiesIndexed();
        logger.info("Auditing {} entities for collection {} in app {}",new Object[]{ids.size(),collectionName,app.getValue()});
        for (        UUID id : ids) {
          boolean reIndex=false;
          Mutator<ByteBuffer> m=createMutator(ko,be);
          for (          String prop : indexed) {
            Object key=key(applicationId,collection.getName(),prop);
            List<HColumn<ByteBuffer,ByteBuffer>> indexCols=scanIndexForAllTypes(ko,indexBucketLocator,applicationId,key,id,prop);
            for (            HColumn<ByteBuffer,ByteBuffer> index : indexCols) {
              DynamicComposite secondaryIndexValue=DynamicComposite.fromByteBuffer(index.getName().duplicate());
              Object code=secondaryIndexValue.get(0);
              Object propValue=secondaryIndexValue.get(1);
              UUID timestampId=(UUID)secondaryIndexValue.get(3);
              DynamicComposite existingEntryStart=new DynamicComposite(prop,code,propValue,timestampId);
              DynamicComposite existingEntryFinish=new DynamicComposite(prop,code,propValue,timestampId);
              setEqualityFlag(existingEntryFinish,ComponentEquality.GREATER_THAN_EQUAL);
              List<HColumn<ByteBuffer,ByteBuffer>> entries=cass.getColumns(ko,ENTITY_INDEX_ENTRIES,id,existingEntryStart,existingEntryFinish,INDEX_ENTRY_LIST_COUNT,false);
              if (entries.size() == 0) {
                logger.info("Could not find reference to value {} for property {} on entity {} in collection{}.  Forcing reindex",new Object[]{propValue,prop,id,collectionName});
                addDeleteToMutator(m,ENTITY_INDEX,key,index.getName().duplicate(),timestamp);
                reIndex=true;
              }
              if (entries.size() > 1) {
                reIndex=true;
              }
            }
          }
          if (reIndex) {
            Entity entity=em.get(id);
            em.update(entity);
            m.execute();
          }
        }
      }
 while (ids.size() == PAGE_SIZE);
    }
  }
}
