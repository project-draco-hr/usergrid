{
  startSpring();
  logger.info("Starting entity cleanup");
  for (  Entry<String,UUID> app : emf.getApplications().entrySet()) {
    logger.info("Starting cleanup for app {}",app.getKey());
    UUID applicationId=app.getValue();
    EntityManagerImpl em=(EntityManagerImpl)emf.getEntityManager(applicationId);
    Application appEntity=em.getApplication();
    if (appEntity == null) {
      logger.warn("Application does not exist in data. {}",app.getKey());
      continue;
    }
    CassandraService cass=em.getCass();
    IndexBucketLocator indexBucketLocator=em.getIndexBucketLocator();
    Keyspace ko=cass.getApplicationKeyspace(applicationId);
    UUID timestampUuid=newTimeUUID();
    long timestamp=getTimestampInMicros(timestampUuid);
    Set<String> collectionNames=em.getApplicationCollections();
    for (    String collectionName : collectionNames) {
      IndexScanner scanner=cass.getIdList(cass.getApplicationKeyspace(applicationId),key(applicationId,DICTIONARY_COLLECTIONS,collectionName),null,null,PAGE_SIZE,false,indexBucketLocator,applicationId,collectionName);
      SliceIterator<UUID> itr=new SliceIterator<UUID>(scanner,null,new UUIDIndexSliceParser(),false);
      while (itr.hasNext()) {
        Set<UUID> ids=itr.next();
        CollectionInfo collection=getDefaultSchema().getCollection("application",collectionName);
        Set<String> indexed=collection.getPropertiesIndexed();
        logger.info("Auditing {} entities for collection {} in app {}",new Object[]{ids.size(),collectionName,app.getValue()});
        for (        UUID id : ids) {
          boolean reIndex=false;
          Mutator<ByteBuffer> m=createMutator(ko,be);
          for (          String prop : indexed) {
            String bucket=indexBucketLocator.getBucket(applicationId,IndexType.COLLECTION,id,prop);
            Object rowKey=key(applicationId,collection.getName(),prop,bucket);
            List<HColumn<ByteBuffer,ByteBuffer>> indexCols=scanIndexForAllTypes(ko,indexBucketLocator,applicationId,rowKey,id,prop);
            for (            HColumn<ByteBuffer,ByteBuffer> index : indexCols) {
              DynamicComposite secondaryIndexValue=DynamicComposite.fromByteBuffer(index.getName().duplicate());
              Object code=secondaryIndexValue.get(0);
              Object propValue=secondaryIndexValue.get(1);
              UUID timestampId=(UUID)secondaryIndexValue.get(3);
              DynamicComposite existingEntryStart=new DynamicComposite(prop,code,propValue,timestampId);
              DynamicComposite existingEntryFinish=new DynamicComposite(prop,code,propValue,timestampId);
              setEqualityFlag(existingEntryFinish,ComponentEquality.GREATER_THAN_EQUAL);
              List<HColumn<ByteBuffer,ByteBuffer>> entries=cass.getColumns(ko,ENTITY_INDEX_ENTRIES,id,existingEntryStart,existingEntryFinish,INDEX_ENTRY_LIST_COUNT,false);
              if (entries.size() == 0) {
                logger.info("Could not find reference to value '{}' for property '{}' on entity {} in collection {}.  Forcing reindex",new Object[]{propValue,prop,id,collectionName});
                addDeleteToMutator(m,ENTITY_INDEX,rowKey,index.getName().duplicate(),timestamp);
                reIndex=true;
              }
              if (entries.size() > 1) {
                reIndex=true;
              }
            }
          }
          if (reIndex) {
            Entity entity=em.get(id);
            if (entity == null) {
              logger.warn("Entity with id {} did not exist in app {}",id,applicationId);
              m.execute();
              continue;
            }
            em.update(entity);
            m.execute();
          }
        }
      }
    }
  }
  logger.info("Completed audit of apps");
}
