{
  super(klass,new AllDefaultPossibilitiesBuilder(true){
    @Override public Runner runnerForClass(    Class<?> testClass) throws Throwable {
      List<RunnerBuilder> builders=Arrays.asList(new RunnerBuilder(){
        @Override public Runner runnerForClass(        Class<?> testClass) throws Throwable {
          Concurrent annotation=testClass.getAnnotation(Concurrent.class);
          if (annotation != null)           return new ConcurrentJunitRunner(testClass);
          return null;
        }
      }
,ignoredBuilder(),annotatedBuilder(),suiteMethodBuilder(),junit3Builder(),junit4Builder());
      for (      RunnerBuilder each : builders) {
        Runner runner=each.safeRunnerForClass(testClass);
        if (runner != null)         return runner;
      }
      return null;
    }
  }
);
  setScheduler(new RunnerScheduler(){
    ExecutorService executorService=Executors.newFixedThreadPool(klass.isAnnotationPresent(Concurrent.class) ? klass.getAnnotation(Concurrent.class).threads() : (int)(Runtime.getRuntime().availableProcessors() * 1.5),new NamedThreadFactory(klass.getSimpleName()));
    CompletionService<Void> completionService=new ExecutorCompletionService<Void>(executorService);
    Queue<Future<Void>> tasks=new LinkedList<Future<Void>>();
    @Override public void schedule(    Runnable childStatement){
      tasks.offer(completionService.submit(childStatement,null));
    }
    @Override public void finished(){
      try {
        while (!tasks.isEmpty())         tasks.remove(completionService.take());
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        while (!tasks.isEmpty())         tasks.poll().cancel(true);
        executorService.shutdownNow();
      }
    }
  }
);
}
