{
  final int maxCount=10;
  final int half=maxCount / 2;
  ConfigurationManager.getConfigInstance().setProperty(CassandraThreadScheduler.RX_IO_THREADS,"" + maxCount);
  final DynamicIntProperty maxThreads=new DynamicIntProperty(CassandraThreadScheduler.RX_IO_THREADS,maxCount);
  final CassandraThreadScheduler cassSchedulerSetup=new CassandraThreadScheduler(maxThreads);
  final Scheduler rxScheduler=cassSchedulerSetup.get();
  final Semaphore semaphore=new Semaphore(0,true);
  CountDownLatch firstHalf=schedule(rxScheduler,half,semaphore);
  CountDownLatch secondHalf=schedule(rxScheduler,half,semaphore);
  try {
    rxScheduler.schedule(new Action0(){
      @Override public void call(){
      }
    }
);
    fail("This should have thrown an exception");
  }
 catch (  RejectedExecutionException ree) {
  }
  ConfigurationManager.getConfigInstance().setProperty(CassandraThreadScheduler.RX_IO_THREADS,"" + half);
  semaphore.release(half);
  boolean completed=firstHalf.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
  try {
    rxScheduler.schedule(new Action0(){
      @Override public void call(){
      }
    }
);
    fail("This should have thrown an exception.  We still don't have capacity for new threads");
  }
 catch (  RejectedExecutionException ree) {
  }
  semaphore.release(maxCount - half);
  completed=secondHalf.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
  CountDownLatch newJob=schedule(rxScheduler,1,semaphore);
  semaphore.release(1);
  completed=newJob.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
}
