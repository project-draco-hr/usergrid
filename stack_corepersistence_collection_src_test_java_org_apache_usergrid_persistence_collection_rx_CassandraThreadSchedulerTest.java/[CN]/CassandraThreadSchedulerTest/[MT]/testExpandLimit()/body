{
  final int startCount=10;
  rxFig.override("getMaxThreadCount",String.valueOf(startCount));
  final CassandraThreadScheduler cassSchedulerSetup=new CassandraThreadScheduler(rxFig);
  final Scheduler rxScheduler=cassSchedulerSetup.get();
  final Semaphore semaphore=new Semaphore(0,true);
  CountDownLatch firstBatch=schedule(rxScheduler,rxFig.getMaxThreadCount(),semaphore,TEST_TIMEOUT);
  try {
    rxScheduler.schedule(new Action0(){
      @Override public void call(){
      }
    }
);
    fail("This should have thrown an exception");
  }
 catch (  RejectedExecutionException ree) {
  }
  final int doubleMaxCount=startCount * 2;
  rxFig.override("getMaxThreadCount",String.valueOf(doubleMaxCount));
  CountDownLatch secondBatch=schedule(rxScheduler,rxFig.getMaxThreadCount() - startCount,semaphore,TEST_TIMEOUT);
  try {
    rxScheduler.schedule(new Action0(){
      @Override public void call(){
      }
    }
);
    fail("This should have thrown an exception");
  }
 catch (  RejectedExecutionException ree) {
  }
  semaphore.release(rxFig.getMaxThreadCount());
  boolean completed=firstBatch.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
  completed=secondBatch.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
  CountDownLatch result=schedule(rxScheduler,1,semaphore,TEST_TIMEOUT);
  semaphore.release(1);
  completed=result.await(20,TimeUnit.SECONDS);
  assertTrue("Completed executing actions",completed);
}
