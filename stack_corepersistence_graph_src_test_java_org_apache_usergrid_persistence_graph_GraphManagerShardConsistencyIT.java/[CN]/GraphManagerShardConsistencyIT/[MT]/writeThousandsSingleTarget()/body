{
  final Id sourceId=createId("source");
  final String edgeType="test";
  EdgeGenerator generator=new EdgeGenerator(){
    @Override public Edge newEdge(){
      Edge edge=createEdge(sourceId,edgeType,createId("target"));
      return edge;
    }
    @Override public Observable<Edge> doSearch(    final GraphManager manager){
      return manager.loadEdgesFromSource(new SimpleSearchByEdgeType(sourceId,"test",System.currentTimeMillis(),null));
    }
  }
;
  final int numInjectors=2;
  final List<Injector> injectors=createInjectors(numInjectors);
  final GraphFig graphFig=getInstance(injectors,GraphFig.class);
  final long shardSize=graphFig.getShardSize();
  final int numProcessors=Runtime.getRuntime().availableProcessors() / 2;
  final int numWorkers=numProcessors / numInjectors;
  final long numberOfEdges=shardSize * 4;
  final long countPerWorker=numberOfEdges / numWorkers;
  final long writeLimit=countPerWorker;
  final long minExecutionTime=graphFig.getShardMinDelta() + graphFig.getShardCacheTimeout();
  final List<Future<Boolean>> futures=new ArrayList<>();
  for (  Injector injector : injectors) {
    final GraphManagerFactory gmf=injector.getInstance(GraphManagerFactory.class);
    futures.addAll(doTest(gmf,generator,numWorkers,writeLimit,minExecutionTime));
  }
  for (  Future<Boolean> future : futures) {
    future.get();
  }
  final NodeShardCache cache=getInstance(injectors,NodeShardCache.class);
  final DirectedEdgeMeta directedEdgeMeta=DirectedEdgeMeta.fromSourceNode(sourceId,edgeType);
  int count=0;
  while (true) {
    count=0;
    final Iterator<ShardEntryGroup> groups=cache.getReadShardGroup(scope,Long.MAX_VALUE,directedEdgeMeta);
    while (groups.hasNext()) {
      final ShardEntryGroup group=groups.next();
      log.info("Compaction pending status for group {} is {}",group,group.isCompactionPending());
      count++;
    }
    if (count == 4) {
      break;
    }
    Thread.sleep(5000);
  }
}
