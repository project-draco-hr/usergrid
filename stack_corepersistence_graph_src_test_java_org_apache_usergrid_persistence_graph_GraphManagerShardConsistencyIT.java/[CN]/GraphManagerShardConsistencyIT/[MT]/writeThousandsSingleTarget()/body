{
  final Id targetId=createId("target");
  final String edgeType="test";
  EdgeGenerator generator=new EdgeGenerator(){
    @Override public Edge newEdge(){
      Edge edge=createEdge(createId("source"),edgeType,targetId);
      return edge;
    }
    @Override public Observable<Edge> doSearch(    final GraphManager manager){
      return manager.loadEdgesToTarget(new SimpleSearchByEdgeType(targetId,"test",System.currentTimeMillis(),null));
    }
  }
;
  final List<Injector> injectors=createInjectors(3);
  final GraphFig graphFig=getInstance(injectors,GraphFig.class);
  final long shardSize=graphFig.getShardSize();
  final long numberOfEdges=shardSize * 4;
  final long countPerWorker=numberOfEdges / numWorkers;
  final long writeLimit=countPerWorker;
  final List<Future<Boolean>> futures=new ArrayList<>();
  for (  Injector injector : injectors) {
    final GraphManagerFactory gmf=injector.getInstance(GraphManagerFactory.class);
    futures.addAll(doTest(gmf,generator,writeLimit));
  }
  for (  Future<Boolean> future : futures) {
    future.get();
  }
  final NodeShardAllocation allocation=getInstance(injectors,NodeShardAllocation.class);
  final DirectedEdgeMeta directedEdgeMeta=DirectedEdgeMeta.fromTargetNode(targetId,edgeType);
  int count=0;
  while (count < 4) {
    count=0;
    final Iterator<ShardEntryGroup> groups=allocation.getShards(scope,Optional.<Shard>absent(),directedEdgeMeta);
    while (groups.hasNext()) {
      final ShardEntryGroup group=groups.next();
      log.info("Compaction pending status for group {} is {}",group,group.isCompactionPending());
      count++;
    }
  }
}
