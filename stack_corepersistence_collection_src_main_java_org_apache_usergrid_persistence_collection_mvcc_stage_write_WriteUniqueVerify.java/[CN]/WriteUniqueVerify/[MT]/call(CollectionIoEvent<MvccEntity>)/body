{
  MvccValidationUtils.verifyMvccEntityWithEntity(ioevent.getEvent());
  final MvccEntity mvccEntity=ioevent.getEvent();
  final Entity entity=mvccEntity.getEntity().get();
  final Id entityId=entity.getId();
  final UUID entityVersion=entity.getVersion();
  final CollectionScope scope=ioevent.getEntityCollection();
  final Collection<Field> entityFields=entity.getFields();
  final List<Field> uniqueFields=new ArrayList<>(entityFields.size());
  final MutationBatch batch=keyspace.prepareMutationBatch();
  for (  final Field field : entityFields) {
    if (field.isUnique()) {
      final UniqueValue written=new UniqueValueImpl(scope,field,entityId,entityVersion);
      final MutationBatch mb=uniqueValueStrat.write(written,serializationFig.getTimeout());
      batch.mergeShallow(mb);
      uniqueFields.add(field);
    }
  }
  if (uniqueFields.size() == 0) {
    return;
  }
  try {
    batch.execute();
  }
 catch (  ConnectionException ex) {
    throw new RuntimeException("Unable to write to cassandra",ex);
  }
  final UniqueValueSet uniqueValues;
  try {
    uniqueValues=uniqueValueStrat.load(scope,uniqueFields);
  }
 catch (  ConnectionException e) {
    throw new RuntimeException("Unable to read from cassandra",e);
  }
  final Map<String,Field> uniquenessViolations=new HashMap<>(uniqueFields.size());
  for (  final Field field : uniqueFields) {
    final UniqueValue uniqueValue=uniqueValues.getValue(field.getName());
    if (uniqueValue == null) {
      throw new RuntimeException(String.format("Could not retrieve unique value for field %s, unable to verify",field.getName()));
    }
    final Id returnedEntityId=uniqueValue.getEntityId();
    if (!entityId.equals(returnedEntityId)) {
      uniquenessViolations.put(field.getName(),field);
    }
  }
  if (!uniquenessViolations.isEmpty()) {
    throw new WriteUniqueVerifyException(mvccEntity,ioevent.getEntityCollection(),uniquenessViolations);
  }
}
