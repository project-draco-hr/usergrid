{
  int size=10000;
  int firstIntersection=100;
  int secondIntersection=200;
  UUID[] firstSet=new UUID[size];
  UUID[] secondSet=new UUID[size];
  UUID[] thirdSet=new UUID[size];
  InOrderIterator first=new InOrderIterator(100);
  InOrderIterator second=new InOrderIterator(100);
  InOrderIterator third=new InOrderIterator(100);
  List<UUID> results=new ArrayList<UUID>(size / secondIntersection);
  for (int i=0; i < size; i++) {
    firstSet[i]=UUIDUtils.newTimeUUID();
    if (i % firstIntersection == 0) {
      secondSet[i]=firstSet[i];
    }
 else {
      secondSet[i]=UUIDUtils.newTimeUUID();
    }
    if (i % secondIntersection == 0) {
      thirdSet[i]=firstSet[i];
      results.add(firstSet[i]);
    }
 else {
      thirdSet[i]=UUIDUtils.newTimeUUID();
    }
  }
  first.add(firstSet);
  reverse(secondSet);
  second.add(secondSet);
  third.add(thirdSet);
  int numPages=2;
  int pageSize=results.size() / numPages;
  IntersectionIterator intersection=new IntersectionIterator(pageSize);
  intersection.addIterator(first);
  intersection.addIterator(second);
  intersection.addIterator(third);
  assertTrue(intersection.hasNext());
  Iterator<UUID> expected=results.iterator();
  Set<ScanColumn> resultSet=intersection.next();
  Iterator<ScanColumn> union=resultSet.iterator();
  while (union.hasNext()) {
    assertTrue(expected.hasNext());
    assertEquals(expected.next(),union.next().getUUID());
  }
  resultSet=intersection.next();
  union=resultSet.iterator();
  while (union.hasNext()) {
    assertTrue(expected.hasNext());
    assertEquals(expected.next(),union.next().getUUID());
  }
  assertFalse(intersection.hasNext());
  assertFalse(expected.hasNext());
}
