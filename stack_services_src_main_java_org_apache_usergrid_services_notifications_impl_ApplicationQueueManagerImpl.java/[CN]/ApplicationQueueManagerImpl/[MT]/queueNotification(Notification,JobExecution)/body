{
  if (scheduleQueueJob(notification)) {
    em.update(notification);
    return;
  }
  final Meter queueMeter=metricsFactory.getMeter(ApplicationQueueManagerImpl.class,"queue");
  long startTime=System.currentTimeMillis();
  if (notification.getCanceled() == Boolean.TRUE) {
    LOG.info("notification " + notification.getUuid() + " canceled");
    if (jobExecution != null) {
      jobExecution.killed();
    }
    return;
  }
  LOG.info("notification {} start queuing",notification.getUuid());
  final PathQuery<Device> pathQuery=notification.getPathQuery();
  final AtomicInteger deviceCount=new AtomicInteger();
  final ConcurrentLinkedQueue<String> errorMessages=new ConcurrentLinkedQueue<String>();
  if (pathQuery != null) {
    final HashMap<Object,ProviderAdapter> notifierMap=getAdapterMap();
    LOG.info("notification {} start query",notification.getUuid());
    final Iterator<Device> iterator=pathQuery.iterator(em);
    if (iterator instanceof ResultsIterator && ((ResultsIterator)iterator).hasPages() && jobExecution == null) {
      jobScheduler.scheduleQueueJob(notification,true);
      em.update(notification);
      return;
    }
    final CountMinSketch sketch=new CountMinSketch(0.0001,.99,7364181);
    final UUID appId=em.getApplication().getUuid();
    final Map<String,Object> payloads=notification.getPayloads();
    final Func1<Entity,Entity> entityListFunct=new Func1<Entity,Entity>(){
      @Override public Entity call(      Entity entity){
        try {
          long now=System.currentTimeMillis();
          List<EntityRef> devicesRef=getDevices(entity);
          LOG.info("notification {} queue  {} devices, duration " + (System.currentTimeMillis() - now) + " ms",notification.getUuid(),devicesRef.size());
          for (          EntityRef deviceRef : devicesRef) {
            LOG.info("notification {} starting to queue device {} ",notification.getUuid(),deviceRef.getUuid());
            long hash=MurmurHash.hash(deviceRef.getUuid());
            if (sketch.estimateCount(hash) > 0) {
              LOG.warn("Maybe Found duplicate device: {}",deviceRef.getUuid());
              continue;
            }
 else {
              sketch.add(hash,1);
            }
            String notifierId=null;
            String notifierKey=null;
            for (            Map.Entry<String,Object> entry : payloads.entrySet()) {
              ProviderAdapter adapter=notifierMap.get(entry.getKey().toLowerCase());
              now=System.currentTimeMillis();
              String providerId=getProviderId(deviceRef,adapter.getNotifier());
              if (providerId != null) {
                notifierId=providerId;
                notifierKey=entry.getKey().toLowerCase();
                break;
              }
              LOG.info("Provider query for notification {} device {} took " + (System.currentTimeMillis() - now) + " ms",notification.getUuid(),deviceRef.getUuid());
            }
            if (notifierId == null) {
              LOG.info("Notifier did not match for device {} ",deviceRef);
              continue;
            }
            ApplicationQueueMessage message=new ApplicationQueueMessage(appId,notification.getUuid(),deviceRef.getUuid(),notifierKey,notifierId);
            if (notification.getQueued() == null) {
              now=System.currentTimeMillis();
              notification.setQueued(System.currentTimeMillis());
              LOG.info("notification {} device {} queue time set. duration " + (System.currentTimeMillis() - now) + " ms",notification.getUuid(),deviceRef.getUuid());
            }
            now=System.currentTimeMillis();
            qm.sendMessage(message);
            LOG.info("notification {} post-queue to device {} duration " + (System.currentTimeMillis() - now) + " ms "+ queueName+ " queue",notification.getUuid(),deviceRef.getUuid());
            deviceCount.incrementAndGet();
            queueMeter.mark();
          }
        }
 catch (        Exception deviceLoopException) {
          LOG.error("Failed to add devices",deviceLoopException);
          errorMessages.add("Failed to add devices for entity: " + entity.getUuid() + " error:"+ deviceLoopException);
        }
        return entity;
      }
    }
;
    long now=System.currentTimeMillis();
    Observable o=rx.Observable.create(new IteratorObservable<Entity>(iterator)).parallel(new Func1<Observable<Entity>,Observable<Entity>>(){
      @Override public rx.Observable<Entity> call(      rx.Observable<Entity> deviceObservable){
        return deviceObservable.map(entityListFunct);
      }
    }
,Schedulers.io()).doOnError(new Action1<Throwable>(){
      @Override public void call(      Throwable throwable){
        LOG.error("Failed while writing",throwable);
      }
    }
);
    o.toBlocking().lastOrDefault(null);
    LOG.info("notification {} done queueing duration {} ms",notification.getUuid(),System.currentTimeMillis() - now);
  }
  Map<String,Object> properties=new HashMap<String,Object>(2);
  properties.put("queued",notification.getQueued());
  properties.put("state",notification.getState());
  if (errorMessages.size() > 0) {
    if (notification.getErrorMessage() == null) {
      notification.setErrorMessage("There was a problem delivering all of your notifications. See deliveryErrors in properties");
    }
  }
  notification.setExpectedCount(deviceCount.get());
  notification.addProperties(properties);
  long now=System.currentTimeMillis();
  LOG.info("notification {} updated notification duration {} ms",notification.getUuid(),System.currentTimeMillis() - now);
  if (deviceCount.get() <= 0 || !notification.getDebug()) {
    TaskManager taskManager=new TaskManager(em,notification);
    taskManager.finishedBatch(false,true);
  }
 else {
    em.update(notification);
  }
  long elapsed=notification.getQueued() != null ? notification.getQueued() - startTime : 0;
  LOG.info("notification {} done queuing to {} devices in " + elapsed + " ms",notification.getUuid().toString(),deviceCount.get());
}
