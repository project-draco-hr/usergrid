{
  ValidationUtils.verifyMvccEntityWithEntity(ioevent.getEvent());
  MvccEntity mvccEntity=ioevent.getEvent();
  final Entity entity=mvccEntity.getEntity().get();
  CollectionScope collectionScope=ioevent.getEntityCollection();
  try {
    List<MvccLogEntry> versions=logEntryStrat.load(collectionScope,entity.getId(),entity.getVersion(),2);
    if (versions.size() > 1 && versions.get(1).getStage().ordinal() < Stage.COMMITTED.ordinal()) {
      log.debug("Conflict writing entity id {} version {}",entity.getId().toString(),entity.getVersion().toString());
      final MvccLogEntry rollbackEntry=new MvccLogEntryImpl(entity.getId(),entity.getVersion(),Stage.ROLLBACK);
      logEntryStrat.write(collectionScope,rollbackEntry);
      List<Observable<FieldDeleteResult>> results=new ArrayList<Observable<FieldDeleteResult>>();
      int uniqueFieldCount=0;
      for (      final Field field : entity.getFields()) {
        if (field.isUnique()) {
          uniqueFieldCount++;
          Observable<FieldDeleteResult> result=Observable.from(field).subscribeOn(scheduler).map(new Func1<Field,FieldDeleteResult>(){
            @Override public FieldDeleteResult call(            Field field){
              UniqueValue toDelete=new UniqueValueImpl(ioevent.getEntityCollection(),field,entity.getId(),entity.getVersion());
              MutationBatch mb=uniqueValueStrat.delete(toDelete);
              try {
                mb.execute();
              }
 catch (              ConnectionException ex) {
                throw new WriteUniqueVerifyException("Error deleting unique value " + field.toString(),ex);
              }
              return new FieldDeleteResult(field.getName());
            }
          }
);
          results.add(result);
        }
      }
      if (uniqueFieldCount > 0) {
        final FuncN<Boolean> zipFunction=new FuncN<Boolean>(){
          @Override public Boolean call(          final Object... args){
            for (            Object resultObj : args) {
              FieldDeleteResult result=(FieldDeleteResult)resultObj;
              log.debug("Rollback deleted field from entity: {} version: {} name: {}",new String[]{entity.getId().toString(),entity.getVersion().toString(),result.getName()});
            }
            return true;
          }
        }
;
        Observable.zip(results,zipFunction).toBlockingObservable().last();
      }
      throw new WriteOptimisticVerifyException("Change conflict, not first writer");
    }
  }
 catch (  ConnectionException e) {
    log.error("Error reading entity log",e);
    throw new CollectionRuntimeException("Error reading entity log",e);
  }
  return ioevent;
}
