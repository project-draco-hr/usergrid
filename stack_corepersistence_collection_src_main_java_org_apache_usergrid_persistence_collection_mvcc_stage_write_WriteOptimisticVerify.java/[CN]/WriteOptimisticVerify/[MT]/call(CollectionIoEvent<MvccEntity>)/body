{
  MvccValidationUtils.verifyMvccEntityWithEntity(ioevent.getEvent());
  MvccEntity mvccEntity=ioevent.getEvent();
  final Entity entity=mvccEntity.getEntity().get();
  CollectionScope collectionScope=ioevent.getEntityCollection();
  if (entity.getVersion() == null) {
    return ioevent;
  }
  try {
    List<MvccLogEntry> versions=logEntryStrat.load(collectionScope,entity.getId(),entity.getVersion(),2);
    if (versions.size() > 1 && versions.get(1).getStage().ordinal() < Stage.COMMITTED.ordinal()) {
      log.debug("Conflict writing entity id {} version {}",entity.getId().toString(),entity.getVersion().toString());
      throw new WriteOptimisticVerifyException(mvccEntity,collectionScope,"Change conflict, not first writer");
    }
  }
 catch (  ConnectionException e) {
    log.error("Error reading entity log",e);
    throw new CollectionRuntimeException(mvccEntity,collectionScope,"Error reading entity log",e);
  }
  return ioevent;
}
