{
  final Timer.Context timer=deleteNodeTimer.time();
  final Meter meter=deleteNodeMeter;
  return Observable.from(node).map(new Func1<Id,Id>(){
    @Override public Id call(    final Id id){
      final UUID eventTimestamp=UUIDGenerator.newTimeUUID();
      final MutationBatch nodeMutation=nodeSerialization.mark(scope,id,timestamp);
      LOG.debug("Marking node {} as deleted to node mark",node);
      try {
        nodeMutation.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to execute mutation",e);
      }
      nodeDeleteListener.receive(scope,id,eventTimestamp).subscribeOn(Schedulers.io()).subscribe(nodeDelete);
      return id;
    }
  }
).doOnEach(new Action1<Notification<? super Id>>(){
    @Override public void call(    Notification<? super Id> notification){
      meter.mark();
    }
  }
).doOnCompleted(new Action0(){
    @Override public void call(){
      timer.stop();
    }
  }
);
}
