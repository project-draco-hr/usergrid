{
  int size=100;
  final Multimap<String,ScanColumn> shards=HashMultimap.create();
  final IndexBucketLocator indexBucketLocator=new SimpleIndexBucketLocatorImpl(20);
  final UUID applicationId=UUIDUtils.newTimeUUID();
  final IndexBucketLocator.IndexType indexType=IndexBucketLocator.IndexType.COLLECTION;
  final String components="things";
  final Set<ScanColumn> allColumns=new LinkedHashSet<ScanColumn>(size);
  final UUIDCursorGenerator uuidCursorGenerator=new UUIDCursorGenerator(1);
  for (int i=0; i < size; i++) {
    final UUID entityId=UUIDUtils.newTimeUUID();
    final String shard=indexBucketLocator.getBucket(applicationId,indexType,entityId,components);
    final UUIDColumn uuidColumn=new UUIDColumn(entityId,1,uuidCursorGenerator);
    shards.put(shard,uuidColumn);
    allColumns.add(uuidColumn);
  }
  for (  final String shard : shards.keySet()) {
    final Set<ScanColumn> expected=new HashSet<ScanColumn>(shards.get(shard));
    final TestIterator testIterator=new TestIterator(new HashSet<ScanColumn>(shards.get(shard)));
    final SliceShardFilterIterator.ShardBucketValidator shardBucketValidator=new SliceShardFilterIterator.ShardBucketValidator(indexBucketLocator,shard,applicationId,indexType,components);
    final SliceShardFilterIterator sliceShardFilterIterator=new SliceShardFilterIterator(shardBucketValidator,testIterator,10);
    while (sliceShardFilterIterator.hasNext()) {
      for (      final ScanColumn column : sliceShardFilterIterator.next()) {
        final boolean contained=expected.remove(column);
        assertTrue("Column should be present",contained);
      }
    }
    assertTrue("expected should be empty",expected.isEmpty());
  }
}
