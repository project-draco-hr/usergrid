{
  IndexValidationUtils.validateIndexScope(indexScope);
  ValidationUtils.verifyIdentity(id);
  ValidationUtils.verifyVersion(version);
  final String context=createContextName(indexScope);
  final String entityType=id.getType();
  final String indexId=createIndexDocId(id,version,context);
  if (log.isDebugEnabled()) {
    log.debug("De-indexing entity {}:{} in scope\n   app {}\n   owner {}\n   " + "name {} context{}, type {},",new Object[]{id.getType(),id.getUuid(),applicationScope.getApplication(),indexScope.getOwner(),indexScope.getName(),context,entityType});
  }
  log.debug("De-indexing type {} with documentId '{}'",entityType,indexId);
  String[] indexes=entityIndex.getIndexes(EntityIndex.AliasType.Read);
  if (indexes == null || indexes.length == 0) {
    indexes=new String[]{indexIdentifier.getIndex(null)};
  }
  final AtomicInteger errorCount=new AtomicInteger();
  Observable.from(indexes).subscribeOn(Schedulers.io()).map(new Func1<String,Object>(){
    @Override public Object call(    String index){
      try {
        bulkRequest.add(client.prepareDelete(index,entityType,indexId).setRefresh(refresh));
      }
 catch (      Exception e) {
        log.error("failed to deindex",e);
        errorCount.incrementAndGet();
      }
      return index;
    }
  }
).toBlocking().last();
  if (errorCount.get() > 0) {
    log.error("Failed to flush some indexes");
  }
  log.debug("Deindexed Entity with index id " + indexId);
  maybeFlush();
  return this;
}
