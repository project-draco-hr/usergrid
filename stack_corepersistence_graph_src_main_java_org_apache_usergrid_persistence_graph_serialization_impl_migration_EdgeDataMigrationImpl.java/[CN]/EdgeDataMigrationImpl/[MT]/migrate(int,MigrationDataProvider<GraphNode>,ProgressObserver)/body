{
  final AtomicLong counter=new AtomicLong();
  final MigrationRelationship<EdgeMetadataSerialization> migration=allVersions.getMigrationRelationship(currentVersion);
  final Observable<List<Edge>> observable=migrationDataProvider.getData().flatMap(new Func1<GraphNode,Observable<List<Edge>>>(){
    @Override public Observable<List<Edge>> call(    final GraphNode graphNode){
      final GraphManager gm=graphManagerFactory.createEdgeManager(graphNode.applicationScope);
      return edgesFromSourceObservable.edgesFromSource(gm,graphNode.entryNode).buffer(1000).parallel(new Func1<Observable<List<Edge>>,Observable<List<Edge>>>(){
        @Override public Observable<List<Edge>> call(        final Observable<List<Edge>> listObservable){
          return listObservable.doOnNext(new Action1<List<Edge>>(){
            @Override public void call(            List<Edge> edges){
              final MutationBatch batch=keyspace.prepareMutationBatch();
              for (              Edge edge : edges) {
                logger.info("Migrating meta for edge {}",edge);
                final MutationBatch edgeBatch=migration.to.writeEdge(graphNode.applicationScope,edge);
                batch.mergeShallow(edgeBatch);
              }
              try {
                batch.execute();
              }
 catch (              ConnectionException e) {
                throw new RuntimeException("Unable to perform migration",e);
              }
              final long newCount=counter.addAndGet(edges.size());
              observer.update(migration.to.getImplementationVersion(),String.format("Currently running.  Rewritten %d edge types",newCount));
            }
          }
);
        }
      }
);
    }
  }
);
  observable.longCount().toBlocking().last();
  return migration.to.getImplementationVersion();
}
