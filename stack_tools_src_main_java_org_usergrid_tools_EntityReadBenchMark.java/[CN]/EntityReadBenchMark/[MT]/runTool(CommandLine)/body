{
  startSpring();
  logger.info("Starting entity cleanup");
  int workerSize=Integer.parseInt(line.getOptionValue("workers"));
  ExecutorService executors=Executors.newFixedThreadPool(workerSize);
  int count=Integer.parseInt(line.getOptionValue("count"));
  int size=count / workerSize;
  UUID appId=UUID.fromString(line.getOptionValue("appId"));
  System.out.println("Querying unique properties in the search index");
  final ConsoleReporter reporter=new ConsoleReporter(Metrics.defaultRegistry(),System.out,MetricPredicate.ALL);
  reporter.start(30,TimeUnit.SECONDS);
  Stack<Future<Void>> futures=new Stack<Future<Void>>();
  String type=line.getOptionValue("type");
  for (int i=0; i < workerSize; i++) {
    ReadWorker worker=null;
    if (TYPE_ENTITY.equals(type)) {
      worker=new IndexReadWorker(i,size,appId);
    }
 else     if (TYPE_DICTIONARY.equals(type)) {
      worker=new DictReadWorker(i,size,appId);
    }
 else {
      throw new IllegalArgumentException("You must specifiy the 'type' option");
    }
    futures.push(executors.submit(worker));
  }
  System.out.println("Waiting for index read workers to complete");
  while (!futures.isEmpty()) {
    futures.pop().get();
  }
  System.out.println("All workers completed reading");
  reporter.run();
}
