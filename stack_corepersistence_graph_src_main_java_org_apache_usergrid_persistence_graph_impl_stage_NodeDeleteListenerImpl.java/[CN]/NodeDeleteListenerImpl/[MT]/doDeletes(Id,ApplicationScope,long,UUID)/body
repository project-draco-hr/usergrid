{
  Observable<MarkedEdge> targetEdges=getEdgesTypesToTarget(scope,new SimpleSearchEdgeType(node,null,null)).subscribeOn(Schedulers.io()).flatMap(new Func1<String,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final String edgeType){
      return Observable.create(new ObservableIterator<MarkedEdge>("getTargetEdges"){
        @Override protected Iterator<MarkedEdge> getIterator(){
          return storageSerialization.getEdgesToTarget(scope,new SimpleSearchByEdgeType(node,edgeType,maxVersion,null));
        }
      }
);
    }
  }
);
  Observable<MarkedEdge> sourceEdges=getEdgesTypesFromSource(scope,new SimpleSearchEdgeType(node,null,null)).subscribeOn(Schedulers.io()).flatMap(new Func1<String,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final String edgeType){
      return Observable.create(new ObservableIterator<MarkedEdge>("getSourceEdges"){
        @Override protected Iterator<MarkedEdge> getIterator(){
          return storageSerialization.getEdgesFromSource(scope,new SimpleSearchByEdgeType(node,edgeType,maxVersion,null));
        }
      }
);
    }
  }
);
  return Observable.merge(targetEdges,sourceEdges).buffer(graphFig.getScanPageSize()).flatMap(new Func1<List<MarkedEdge>,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final List<MarkedEdge> markedEdges){
      LOG.debug("Batching {} edges for node {} for deletion",markedEdges.size(),node);
      final MutationBatch batch=keyspace.prepareMutationBatch();
      Set<TargetPair> sourceNodes=new HashSet<>(markedEdges.size());
      Set<TargetPair> targetNodes=new HashSet<>(markedEdges.size());
      for (      MarkedEdge edge : markedEdges) {
        batch.mergeShallow(storageSerialization.deleteEdge(scope,edge,eventTimestamp));
        sourceNodes.add(new TargetPair(edge.getSourceNode(),edge.getType()));
        targetNodes.add(new TargetPair(edge.getTargetNode(),edge.getType()));
      }
      try {
        batch.execute();
      }
 catch (      ConnectionException e) {
        throw new GraphRuntimeException("Unable to delete edges",e);
      }
      LOG.debug("About to audit {} source types",sourceNodes.size());
      Observable<Integer> sourceMetaCleanup=Observable.from(sourceNodes).flatMap(new Func1<TargetPair,Observable<Integer>>(){
        @Override public Observable<Integer> call(        final TargetPair targetPair){
          return edgeMetaRepair.repairSources(scope,targetPair.id,targetPair.edgeType,maxVersion);
        }
      }
).last();
      LOG.debug("About to audit {} target types",targetNodes.size());
      Observable<Integer> targetMetaCleanup=Observable.from(targetNodes).flatMap(new Func1<TargetPair,Observable<Integer>>(){
        @Override public Observable<Integer> call(        final TargetPair targetPair){
          return edgeMetaRepair.repairTargets(scope,targetPair.id,targetPair.edgeType,maxVersion);
        }
      }
).last();
      return Observable.merge(sourceMetaCleanup,targetMetaCleanup).lastOrDefault(null).flatMap(new Func1<Integer,Observable<MarkedEdge>>(){
        @Override public Observable<MarkedEdge> call(        final Integer integer){
          return Observable.from(markedEdges);
        }
      }
);
    }
  }
);
}
