{
  List<EntityLocationRef> entityLocations=new ArrayList<EntityLocationRef>(maxResults);
  EntityLocationRef minMatch=startResult;
  if (minMatch == null) {
    minMatch=new EntityLocationRef((String)null,UUIDUtils.MIN_TIME_UUID,searchPoint.getLat(),searchPoint.getLon());
    minMatch.calcDistance(searchPoint);
  }
  List<String> curGeocells=new ArrayList<String>();
  String curContainingGeocell=null;
  if (geoCells != null && geoCells.size() > 0) {
    curGeocells.addAll(geoCells);
    curContainingGeocell=geoCells.get(0);
  }
 else {
    curContainingGeocell=GeocellUtils.compute(searchPoint,MAX_GEOCELL_RESOLUTION);
    curGeocells.add(curContainingGeocell);
  }
  Set<String> searchedCells=new HashSet<String>();
  List<String> curGeocellsUnique=null;
  double closestPossibleNextResultDist=0;
  int noDirection[]={0,0};
  List<Tuple<int[],Double>> sortedEdgesDistances=Arrays.asList(new Tuple<int[],Double>(noDirection,0d));
  boolean done=false;
  UUID lastReturned=null;
  while (!curGeocells.isEmpty() && entityLocations.size() < maxResults) {
    closestPossibleNextResultDist=sortedEdgesDistances.get(0).getSecond();
    if (maxDistance > 0 && closestPossibleNextResultDist > maxDistance) {
      break;
    }
    Set<String> curTempUnique=new HashSet<String>(curGeocells);
    curTempUnique.removeAll(searchedCells);
    curGeocellsUnique=new ArrayList<String>(curTempUnique);
    Set<EntityLocationRef> queryResults=null;
    do {
      queryResults=doSearch(curGeocellsUnique,lastReturned,1000);
      if (logger.isDebugEnabled()) {
        logger.debug("fetch complete for: {}",StringUtils.join(curGeocellsUnique,", "));
      }
      searchedCells.addAll(curGeocells);
      for (      EntityLocationRef entityLocation : queryResults) {
        lastReturned=entityLocation.getUuid();
        double distance=entityLocation.getDistance();
        if (distance < minDistance || (maxDistance != 0 && distance > maxDistance)) {
          continue;
        }
        int index=Collections.binarySearch(entityLocations,entityLocation);
        if (index > -1) {
          if (entityLocations.get(index).equals(entityLocation)) {
            continue;
          }
          index++;
        }
 else {
          index=(index + 1) * -1;
        }
        if (index >= maxResults) {
          continue;
        }
        entityLocations.add(index,entityLocation);
        while (entityLocations.size() > maxResults) {
          entityLocations.remove(entityLocations.size() - 1);
        }
      }
    }
 while (queryResults != null && queryResults.size() > 0);
    if (done || entityLocations.size() == maxResults) {
      break;
    }
    sortedEdgesDistances=GeocellUtils.distanceSortedEdges(curGeocells,searchPoint);
    if (queryResults.size() == 0 || curGeocells.size() == 4) {
      curContainingGeocell=curContainingGeocell.substring(0,Math.max(curContainingGeocell.length() - 1,0));
      if (curContainingGeocell.length() == 0) {
        curGeocells.clear();
        String[] items="0123456789abcdef".split("(?!^)");
        for (        String item : items)         curGeocells.add(item);
        done=true;
      }
 else {
        List<String> oldCurGeocells=new ArrayList<String>(curGeocells);
        curGeocells.clear();
        for (        String cell : oldCurGeocells) {
          if (cell.length() > 0) {
            String newCell=cell.substring(0,cell.length() - 1);
            if (!curGeocells.contains(newCell)) {
              curGeocells.add(newCell);
            }
          }
        }
      }
    }
 else     if (curGeocells.size() == 1) {
      for (int i=0; i < sortedEdgesDistances.size(); i++) {
        int nearestEdge[]=sortedEdgesDistances.get(i).getFirst();
        String edge=GeocellUtils.adjacent(curGeocells.get(0),nearestEdge);
        if (edge == null) {
          continue;
        }
        curGeocells.add(edge);
        break;
      }
    }
 else     if (curGeocells.size() == 2) {
      int nearestEdge[]=GeocellUtils.distanceSortedEdges(Arrays.asList(curContainingGeocell),searchPoint).get(0).getFirst();
      int[] perpendicularNearestEdge={0,0};
      if (nearestEdge[0] == 0) {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] != 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
 else {
        for (        Tuple<int[],Double> edgeDistance : sortedEdgesDistances) {
          if (edgeDistance.getFirst()[0] == 0) {
            perpendicularNearestEdge=edgeDistance.getFirst();
            break;
          }
        }
      }
      List<String> tempCells=new ArrayList<String>();
      for (      String cell : curGeocells) {
        tempCells.add(GeocellUtils.adjacent(cell,perpendicularNearestEdge));
      }
      curGeocells.addAll(tempCells);
    }
    if (entityLocations.size() < maxResults) {
      logger.debug("{} results found but want {} results, continuing search.",entityLocations.size(),maxResults);
      continue;
    }
    logger.debug("{} results found.",entityLocations.size());
  }
  return new SearchResults(entityLocations,curGeocells);
}
