{
  if (listeners.size() == 0) {
    LOG.warn("Nothing is listening for event of class {}.  You're talking to /dev/null!",event.getEvent().getClass());
  }
  final T data=event.getEvent();
  List<Observable<?>> observables=new ArrayList<Observable<?>>(listeners.size());
  for (  MessageListener<T,?> listener : listeners) {
    observables.add(HystrixObservable.async(listener.receive(data)).subscribeOn(Schedulers.io()));
  }
  LOG.debug("About to start {} observables for event {}",listeners.size(),event);
  Observable.zip(observables,new FuncN<AsynchronousMessage<T>>(){
    @Override public AsynchronousMessage<T> call(    final Object... args){
      return event;
    }
  }
).subscribe(new Subscriber<AsynchronousMessage<T>>(){
    @Override public void onCompleted(){
      LOG.debug("Successfully completed processing for event {}",event);
      queue.remove(event);
      for (      CompleteListener<T> listener : completeListeners) {
        listener.onComplete(event);
      }
    }
    @Override public void onError(    final Throwable throwable){
      LOG.error("Unable to process async event",throwable);
      for (      ErrorListener listener : errorListeners) {
        listener.onError(event,throwable);
      }
    }
    @Override public void onNext(    final AsynchronousMessage<T> tAsynchronousMessage){
    }
  }
);
}
