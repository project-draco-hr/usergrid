{
  final Id node=edgeEvent.getData();
  final OrganizationScope scope=edgeEvent.getOrganizationScope();
  final UUID version=edgeEvent.getVersion();
  return Observable.from(node).subscribeOn(Schedulers.io()).map(new Func1<Id,Optional<UUID>>(){
    @Override public Optional<UUID> call(    final Id id){
      return nodeSerialization.getMaxVersion(scope,node);
    }
  }
).takeWhile(new Func1<Optional<UUID>,Boolean>(){
    @Override public Boolean call(    final Optional<UUID> uuidOptional){
      LOG.debug("Node with id {} has max version of {}",node,uuidOptional.orNull());
      return uuidOptional.isPresent();
    }
  }
).flatMap(new Func1<Optional<UUID>,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final Optional<UUID> uuidOptional){
      Observable<MarkedEdge> targetEdges=getEdgesTypesToTarget(scope,new SimpleSearchEdgeType(node,null)).subscribeOn(Schedulers.io()).flatMap(new Func1<String,Observable<MarkedEdge>>(){
        @Override public Observable<MarkedEdge> call(        final String edgeType){
          return loadEdgesToTarget(scope,new SimpleSearchByEdgeType(node,edgeType,version,null));
        }
      }
);
      Observable<MarkedEdge> sourceEdges=getEdgesTypesFromSource(scope,new SimpleSearchEdgeType(node,null)).subscribeOn(Schedulers.io()).flatMap(new Func1<String,Observable<MarkedEdge>>(){
        @Override public Observable<MarkedEdge> call(        final String edgeType){
          return loadEdgesFromSource(scope,new SimpleSearchByEdgeType(node,edgeType,version,null));
        }
      }
);
      return Observable.merge(targetEdges,sourceEdges);
    }
  }
).buffer(graphFig.getScanPageSize()).flatMap(new Func1<List<MarkedEdge>,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final List<MarkedEdge> markedEdges){
      LOG.debug("Batching {} edges for node {} for deletion",markedEdges.size(),node);
      final MutationBatch batch=keyspace.prepareMutationBatch();
      Set<TargetPair> sourceNodes=new HashSet<TargetPair>(markedEdges.size());
      Set<TargetPair> targetNodes=new HashSet<TargetPair>(markedEdges.size());
      for (      MarkedEdge edge : markedEdges) {
        final MutationBatch delete=edgeSerialization.deleteEdge(scope,edge);
        batch.mergeShallow(delete);
        sourceNodes.add(new TargetPair(edge.getSourceNode(),edge.getType()));
        targetNodes.add(new TargetPair(edge.getTargetNode(),edge.getType()));
      }
      try {
        batch.execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to delete edges",e);
      }
      LOG.debug("About to audit {} source types",sourceNodes.size());
      Observable<Integer> sourceMetaCleanup=Observable.from(sourceNodes).flatMap(new Func1<TargetPair,Observable<Integer>>(){
        @Override public Observable<Integer> call(        final TargetPair targetPair){
          return edgeMetaRepair.repairSources(scope,targetPair.id,targetPair.edgeType,version);
        }
      }
).last();
      LOG.debug("About to audit {} target types",targetNodes.size());
      Observable<Integer> targetMetaCleanup=Observable.from(targetNodes).flatMap(new Func1<TargetPair,Observable<Integer>>(){
        @Override public Observable<Integer> call(        final TargetPair targetPair){
          return edgeMetaRepair.repairTargets(scope,targetPair.id,targetPair.edgeType,version);
        }
      }
).last();
      return Observable.merge(sourceMetaCleanup,targetMetaCleanup).last().flatMap(new Func1<Integer,Observable<MarkedEdge>>(){
        @Override public Observable<MarkedEdge> call(        final Integer integer){
          return Observable.from(markedEdges);
        }
      }
);
    }
  }
).count().defaultIfEmpty(0).doOnCompleted(new Action0(){
    @Override public void call(){
      try {
        nodeSerialization.delete(scope,node,version).execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to delete marked graph node " + node,e);
      }
    }
  }
);
}
