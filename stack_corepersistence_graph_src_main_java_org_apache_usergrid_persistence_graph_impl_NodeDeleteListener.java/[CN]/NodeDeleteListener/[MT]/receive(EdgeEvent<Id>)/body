{
  final Id node=edgeEvent.getData();
  final OrganizationScope scope=edgeEvent.getOrganizationScope();
  final UUID version=edgeEvent.getVersion();
  return Observable.from(node).subscribeOn(Schedulers.io()).map(new Func1<Id,Optional<UUID>>(){
    @Override public Optional<UUID> call(    final Id id){
      return nodeSerialization.getMaxVersion(scope,node);
    }
  }
).takeWhile(new Func1<Optional<UUID>,Boolean>(){
    @Override public Boolean call(    final Optional<UUID> uuidOptional){
      LOG.debug("Node with id {} has max version of {}",node,uuidOptional.orNull());
      return uuidOptional.isPresent();
    }
  }
).flatMap(new Func1<Optional<UUID>,Observable<MarkedEdge>>(){
    @Override public Observable<MarkedEdge> call(    final Optional<UUID> uuidOptional){
      Observable<MarkedEdge> commitLogRemovals=doDeletes(commitLogSerialization,new NodeMutator(){
        @Override public MutationBatch doDeleteMutation(        final OrganizationScope scope,        final MarkedEdge edge){
          final MutationBatch commitBatch=commitLogSerialization.deleteEdge(scope,edge);
          final MutationBatch storageBatch=storageSerialization.deleteEdge(scope,edge);
          commitBatch.mergeShallow(storageBatch);
          return commitBatch;
        }
      }
,node,scope,version);
      Observable<MarkedEdge> storageRemovals=doDeletes(storageSerialization,new NodeMutator(){
        @Override public MutationBatch doDeleteMutation(        final OrganizationScope scope,        final MarkedEdge edge){
          final MutationBatch storageBatch=storageSerialization.deleteEdge(scope,edge);
          return storageBatch;
        }
      }
,node,scope,version);
      return Observable.merge(commitLogRemovals,storageRemovals);
    }
  }
).count().defaultIfEmpty(0).doOnCompleted(new Action0(){
    @Override public void call(){
      try {
        nodeSerialization.delete(scope,node,version).execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to delete marked graph node " + node,e);
      }
    }
  }
);
}
