{
  Preconditions.checkNotNull(elasticsearchIndexEvent,"elasticsearchIndexEvent cannot be null");
  final UUID messageId=elasticsearchIndexEvent.getIndexBatchId();
  Preconditions.checkNotNull(messageId,"messageId must not be null");
  final String message=esMapPersistence.getString(messageId.toString());
  final IndexOperationMessage indexOperationMessage;
  if (message == null) {
    if (System.currentTimeMillis() > elasticsearchIndexEvent.getCreationTime() + queueFig.getLocalQuorumTimeout()) {
      logger.warn("Received message with id {} to process, unable to find it, reading with higher consistency level",messageId);
      final String highConsistency=esMapPersistence.getStringHighConsistency(messageId.toString());
      if (highConsistency == null) {
        logger.error("Unable to find the ES batch with id {} to process at a higher consistency level",messageId);
        throw new RuntimeException("Unable to find the ES batch to process with message id " + messageId);
      }
      indexOperationMessage=ObjectJsonSerializer.INSTANCE.fromString(highConsistency,IndexOperationMessage.class);
    }
 else {
      throw new IndexDocNotFoundException(elasticsearchIndexEvent.getIndexBatchId());
    }
  }
 else {
    indexOperationMessage=ObjectJsonSerializer.INSTANCE.fromString(message,IndexOperationMessage.class);
  }
  initializeEntityIndexes(indexOperationMessage);
  Preconditions.checkNotNull(indexOperationMessage,"indexOperationMessage cannot be null");
  Preconditions.checkArgument(!indexOperationMessage.isEmpty(),"queued indexOperationMessage messages should not be empty");
  return indexOperationMessage;
}
