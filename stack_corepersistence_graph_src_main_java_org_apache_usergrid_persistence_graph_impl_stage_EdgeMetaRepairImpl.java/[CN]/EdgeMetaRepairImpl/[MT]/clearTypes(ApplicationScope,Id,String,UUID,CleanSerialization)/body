{
  ValidationUtils.validateApplicationScope(scope);
  ValidationUtils.verifyIdentity(node);
  Preconditions.checkNotNull(edgeType,"edge type is required");
  Preconditions.checkNotNull(version,"version is required");
  Preconditions.checkNotNull(serialization,"serialization is required");
  Observable<Integer> deleteCounts=serialization.loadEdgeSubTypes(scope,node,edgeType,version).buffer(graphFig.getRepairConcurrentSize()).flatMap(new Func1<List<String>,Observable<Integer>>(){
    @Override public Observable<Integer> call(    final List<String> types){
      final MutationBatch batch=keyspace.prepareMutationBatch();
      final List<Observable<Integer>> checks=new ArrayList<Observable<Integer>>(types.size());
      for (      final String subType : types) {
        LOG.debug("Checking for edges with nodeId {}, type {}, and subtype {}",node,edgeType,subType);
        Observable<Integer> search=serialization.loadEdges(scope,node,edgeType,subType,version).doOnNext(RX_LOG).take(1).count().doOnNext(new Action1<Integer>(){
          @Override public void call(          final Integer count){
            if (count != 0) {
              LOG.debug("Found edge with nodeId {}, type {}, " + "and subtype {}. Not removing subtype. ",node,edgeType,subType);
              return;
            }
            LOG.debug("No edges with nodeId {}, type {}, " + "and subtype {}. Removing subtype.",node,edgeType,subType);
            batch.mergeShallow(serialization.removeEdgeSubType(scope,node,edgeType,subType,version));
          }
        }
);
        checks.add(search);
      }
      return MathObservable.sumInteger(Observable.merge(checks)).doOnNext(new Action1<Integer>(){
        @Override public void call(        final Integer count){
          LOG.debug("Executing batch for subtype deletion with type {}.  " + "Mutation has {} rows to mutate ",edgeType,batch.getRowCount());
          try {
            batch.execute();
          }
 catch (          ConnectionException e) {
            throw new RuntimeException("Unable to execute mutation",e);
          }
        }
      }
);
    }
  }
).defaultIfEmpty(0);
  return MathObservable.sumInteger(deleteCounts).lastOrDefault(0).doOnNext(new Action1<Integer>(){
    @Override public void call(    final Integer subTypeUsedCount){
      if (subTypeUsedCount != 0) {
        LOG.debug("Type {} has {} subtypes in use as of version {}.  Not deleting type.",edgeType,subTypeUsedCount,version);
        return;
      }
      try {
        LOG.debug("Type {} has no subtypes in use as of version {}.  Deleting type.",edgeType,version);
        serialization.removeEdgeType(scope,node,edgeType,version).execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to execute mutation");
      }
    }
  }
);
}
