{
  ValidationUtils.validateOrganizationScope(scope);
  ValidationUtils.verifyIdentity(node);
  Preconditions.checkNotNull(edgeType,"edge type is required");
  Preconditions.checkNotNull(version,"version is required");
  Observable<Integer> deleteCounts=serialization.loadEdgeSubTypes(scope,node,edgeType,version).buffer(graphFig.getRepairConcurrentSize()).flatMap(new Func1<List<String>,Observable<Integer>>(){
    @Override public Observable<Integer> call(    final List<String> types){
      final MutationBatch batch=keyspace.prepareMutationBatch();
      final List<Observable<Integer>> checks=new ArrayList<Observable<Integer>>(types.size());
      for (      final String sourceIdType : types) {
        Observable<Integer> search=serialization.loadEdges(scope,node,edgeType,sourceIdType,version).distinctUntilChanged(new Func1<MarkedEdge,Id>(){
          @Override public Id call(          final MarkedEdge markedEdge){
            return markedEdge.getSourceNode();
          }
        }
).take(1).count().doOnNext(new Action1<Integer>(){
          @Override public void call(          final Integer count){
            if (count != 0) {
              return;
            }
            batch.mergeShallow(serialization.removeEdgeSubType(scope,node,edgeType,sourceIdType,version));
          }
        }
);
        checks.add(search);
      }
      return MathObservable.sumInteger(Observable.merge(checks)).doOnNext(new Action1<Integer>(){
        @Override public void call(        final Integer count){
          if (batch.isEmpty()) {
            return;
          }
          try {
            batch.execute();
          }
 catch (          ConnectionException e) {
            throw new RuntimeException("Unable to execute mutation",e);
          }
        }
      }
);
    }
  }
).defaultIfEmpty(0);
  return MathObservable.sumInteger(deleteCounts).last().doOnNext(new Action1<Integer>(){
    @Override public void call(    final Integer subTypes){
      if (subTypes != 0) {
        return;
      }
      try {
        serialization.removeEdgeType(scope,node,edgeType,version).execute();
      }
 catch (      ConnectionException e) {
        throw new RuntimeException("Unable to execute mutation");
      }
    }
  }
);
}
