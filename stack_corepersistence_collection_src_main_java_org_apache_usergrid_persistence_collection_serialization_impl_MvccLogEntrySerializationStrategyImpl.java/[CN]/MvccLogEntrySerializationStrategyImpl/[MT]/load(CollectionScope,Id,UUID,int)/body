{
  Preconditions.checkNotNull(collectionScope,"collectionScope is required");
  Preconditions.checkNotNull(entityId,"entity id is required");
  Preconditions.checkNotNull(version,"version is required");
  Preconditions.checkArgument(maxSize > 0,"max Size must be greater than 0");
  ColumnList<UUID> columns;
  try {
    final Id applicationId=collectionScope.getApplication();
    final Id ownerId=collectionScope.getOwner();
    final String collectionName=collectionScope.getName();
    final CollectionPrefixedKey<Id> collectionPrefixedKey=new CollectionPrefixedKey<>(collectionName,ownerId,entityId);
    final ScopedRowKey<CollectionPrefixedKey<Id>> rowKey=ScopedRowKey.fromKey(applicationId,collectionPrefixedKey);
    columns=keyspace.prepareQuery(CF_ENTITY_LOG).getKey(rowKey).withColumnRange(version,null,false,maxSize).execute().getResult();
  }
 catch (  ConnectionException e) {
    throw new RuntimeException("Unable to load log entries",e);
  }
  List<MvccLogEntry> results=new ArrayList<MvccLogEntry>(columns.size());
  for (  Column<UUID> col : columns) {
    final UUID storedVersion=col.getName();
    final StageStatus stage=col.getValue(SER);
    results.add(new MvccLogEntryImpl(entityId,storedVersion,stage.stage,stage.state));
  }
  return results;
}
