{
  Thread.currentThread().setDaemon(true);
  Thread.currentThread().setName("Notifications_Processor" + UUID.randomUUID());
  final AtomicInteger consecutiveExceptions=new AtomicInteger();
  LOG.info("QueueListener: Starting execute process.");
  while (true) {
    try {
      svcMgr=smf.getServiceManager(smf.getManagementAppId());
      queueManager=svcMgr.getQueueManager();
      String queueName=ApplicationQueueManager.getRandomQueue(queueNames);
      LOG.info("getting from queue {} ",queueName);
      QueueResults results=getDeliveryBatch(queueManager,queueName);
      LOG.info("QueueListener: retrieved batch of {} messages from queue {} ",results.size(),queueName);
      List<Message> messages=results.getMessages();
      if (messages.size() > 0) {
        HashMap<UUID,List<ApplicationQueueMessage>> messageMap=new HashMap<>(messages.size());
        for (        Message message : messages) {
          ApplicationQueueMessage queueMessage=ApplicationQueueMessage.generate(message);
          UUID applicationId=queueMessage.getApplicationId();
          if (!messageMap.containsKey(applicationId)) {
            List<ApplicationQueueMessage> applicationQueueMessages=new ArrayList<ApplicationQueueMessage>();
            applicationQueueMessages.add(queueMessage);
            messageMap.put(applicationId,applicationQueueMessages);
          }
 else {
            messageMap.get(applicationId).add(queueMessage);
          }
        }
        long now=System.currentTimeMillis();
        Observable merge=null;
        for (        Map.Entry<UUID,List<ApplicationQueueMessage>> entry : messageMap.entrySet()) {
          UUID applicationId=entry.getKey();
          EntityManager entityManager=emf.getEntityManager(applicationId);
          ServiceManager serviceManager=smf.getServiceManager(applicationId);
          final ApplicationQueueManager manager=new ApplicationQueueManager(new JobScheduler(serviceManager,entityManager),entityManager,queueManager,metricsService,properties);
          LOG.info("QueueListener: send batch for app {} of {} messages",entry.getKey(),entry.getValue().size());
          Observable current=manager.sendBatchToProviders(entry.getValue(),queueName);
          if (merge == null)           merge=current;
 else {
            merge=Observable.merge(merge,current);
          }
        }
        if (merge != null) {
          merge.toBlocking().lastOrDefault(null);
        }
        LOG.info("QueueListener: sent batch {} messages duration {} ms",messages.size(),System.currentTimeMillis() - now);
        if (sleepBetweenRuns > 0) {
          LOG.info("QueueListener: sleep between rounds...sleep...{}",sleepBetweenRuns);
          Thread.sleep(sleepBetweenRuns);
        }
      }
 else {
        LOG.info("QueueListener: no messages...sleep...{}",sleepWhenNoneFound);
        Thread.sleep(sleepWhenNoneFound);
      }
      consecutiveExceptions.set(0);
    }
 catch (    Exception ex) {
      LOG.error("failed to dequeue",ex);
      try {
        long sleeptime=sleepWhenNoneFound * consecutiveExceptions.incrementAndGet();
        long maxSleep=15000;
        sleeptime=sleeptime > maxSleep ? maxSleep : sleeptime;
        LOG.info("sleeping due to failures {} ms",sleeptime);
        Thread.sleep(sleeptime);
      }
 catch (      InterruptedException ie) {
        LOG.info("sleep interrupted");
      }
    }
  }
}
