{
  svcMgr=smf.getServiceManager(smf.getManagementAppId());
  queueManager=svcMgr.getQueueManager();
  final AtomicInteger consecutiveExceptions=new AtomicInteger();
  LOG.info("QueueListener: Starting execute process.");
  while (true) {
    try {
      QueueResults results=ApplicationQueueManager.getDeliveryBatch(queueManager);
      LOG.info("QueueListener: retrieved batch of {} messages",results.size());
      List<Message> messages=results.getMessages();
      if (messages.size() > 0) {
        Observable.from(messages).subscribeOn(Schedulers.io()).map(new Func1<Message,ApplicationQueueMessage>(){
          @Override public ApplicationQueueMessage call(          Message message){
            return ApplicationQueueMessage.generate(message);
          }
        }
).groupBy(new Func1<ApplicationQueueMessage,UUID>(){
          @Override public UUID call(          ApplicationQueueMessage message){
            return message.getApplicationId();
          }
        }
).flatMap(new Func1<GroupedObservable<UUID,ApplicationQueueMessage>,Observable<?>>(){
          @Override public Observable<?> call(          GroupedObservable<UUID,ApplicationQueueMessage> groupedObservable){
            UUID appId=groupedObservable.getKey();
            EntityManager entityManager=emf.getEntityManager(appId);
            ServiceManager serviceManager=smf.getServiceManager(appId);
            final ApplicationQueueManager manager=new ApplicationQueueManager(new JobScheduler(serviceManager,entityManager),entityManager,queueManager,metricsService,properties);
            return groupedObservable.buffer(ApplicationQueueManager.BATCH_SIZE).flatMap(new Func1<List<ApplicationQueueMessage>,Observable<?>>(){
              @Override public Observable<?> call(              List<ApplicationQueueMessage> queueMessages){
                LOG.info("QueueListener: send batch {} messages",queueMessages.size());
                return manager.sendBatchToProviders(queueMessages);
              }
            }
);
          }
        }
).doOnError(new Action1<Throwable>(){
          @Override public void call(          Throwable throwable){
            LOG.error("Failed while listening",throwable);
          }
        }
).toBlocking().last();
        LOG.info("QueueListener: Messages sent in batch");
        if (sleepBetweenRuns > 0) {
          Thread.sleep(sleepBetweenRuns);
        }
      }
 else {
        LOG.info("QueueListener: no messages...sleep...",results.size());
        Thread.sleep(sleepWhenNoneFound);
      }
      consecutiveExceptions.set(0);
    }
 catch (    Exception ex) {
      LOG.error("failed to dequeue",ex);
      if (consecutiveExceptions.getAndIncrement() > MAX_CONSECUTIVE_FAILS) {
        LOG.error("killing message listener; too many failures");
        break;
      }
    }
  }
}
