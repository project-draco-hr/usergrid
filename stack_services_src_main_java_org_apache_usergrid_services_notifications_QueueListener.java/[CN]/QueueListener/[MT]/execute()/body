{
  svcMgr=smf.getServiceManager(smf.getManagementAppId());
  queueManager=svcMgr.getQueueManager();
  final AtomicInteger consecutiveExceptions=new AtomicInteger();
  LOG.info("QueueListener: Starting execute process.");
  while (true) {
    try {
      QueueResults results=ApplicationQueueManager.getDeliveryBatch(queueManager);
      LOG.info("QueueListener: retrieved batch of {} messages",results.size());
      List<Message> messages=results.getMessages();
      if (messages.size() > 0) {
        HashMap<UUID,List<ApplicationQueueMessage>> messageMap=new HashMap<>(messages.size());
        for (        Message message : messages) {
          ApplicationQueueMessage queueMessage=ApplicationQueueMessage.generate(message);
          UUID applicationId=queueMessage.getApplicationId();
          if (!messageMap.containsKey(applicationId)) {
            List<ApplicationQueueMessage> applicationQueueMessages=new ArrayList<ApplicationQueueMessage>();
            applicationQueueMessages.add(queueMessage);
            messageMap.put(applicationId,applicationQueueMessages);
          }
 else {
            messageMap.get(applicationId).add(queueMessage);
          }
        }
        long now=System.currentTimeMillis();
        Observable merge=null;
        for (        Map.Entry<UUID,List<ApplicationQueueMessage>> entry : messageMap.entrySet()) {
          UUID applicationId=entry.getKey();
          EntityManager entityManager=emf.getEntityManager(applicationId);
          ServiceManager serviceManager=smf.getServiceManager(applicationId);
          final ApplicationQueueManager manager=new ApplicationQueueManager(new JobScheduler(serviceManager,entityManager),entityManager,queueManager,metricsService,properties);
          LOG.info("QueueListener: send batch for app {} of {} messages",entry.getKey(),entry.getValue().size());
          Observable current=manager.sendBatchToProviders(entry.getValue());
          if (merge == null)           merge=current;
 else {
            merge=Observable.merge(merge,current);
          }
        }
        if (merge != null) {
          merge.toBlocking().lastOrDefault(null);
        }
        LOG.info("QueueListener: sent batch {} messages duration {} ms",messages.size(),System.currentTimeMillis() - now);
        if (sleepBetweenRuns > 0) {
          Thread.sleep(sleepBetweenRuns);
        }
      }
 else {
        LOG.info("QueueListener: no messages...sleep...",results.size());
        Thread.sleep(sleepWhenNoneFound);
      }
      consecutiveExceptions.set(0);
    }
 catch (    Exception ex) {
      LOG.error("failed to dequeue",ex);
      if (consecutiveExceptions.getAndIncrement() > MAX_CONSECUTIVE_FAILS) {
        LOG.error("killing message listener; too many failures");
        break;
      }
    }
  }
}
